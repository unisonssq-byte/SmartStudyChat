{"file_contents":{"pyproject.toml":{"content":"[project]\nname = \"repl-nix-workspace\"\nversion = \"0.1.0\"\ndescription = \"Add your description here\"\nrequires-python = \">=3.11\"\ndependencies = [\n    \"aiofiles>=24.1.0\",\n    \"aiogram>=3.22.0\",\n    \"aiosqlite>=0.21.0\",\n    \"matplotlib>=3.10.6\",\n    \"openai>=1.108.1\",\n    \"pillow>=11.3.0\",\n    \"requests>=2.32.5\",\n]\n","size_bytes":311},"replit.md":{"content":"# Custos Telegram Bot | Чат-менеджер\n\n## Overview\nThis is a Python Telegram bot project called \"Custos | Чат-менеджер\" - a simplified chat management bot built with aiogram. The bot provides moderation features, user ranking system, and various administrative commands for Telegram group chats.\n\n## Project Structure\n```\nCustosBot/\n├── main.py                 # Main bot entry point\n├── config.py               # Bot configuration and settings\n├── requirements.txt        # Python dependencies\n├── INSTALLATION.md        # Server installation guide\n├── handlers/               # Command handlers\n│   ├── __init__.py\n│   ├── main_handlers.py\n│   ├── moderation_handlers.py\n│   └── user_handlers.py\n├── keyboards/              # Bot keyboards and buttons\n│   └── main_keyboards.py\n├── data/                   # Database and data management\n│   ├── database.py         # Database class and operations\n│   └── custos.db          # SQLite database file\n├── utils/                  # Utility functions\n│   ├── __init__.py\n│   └── image_generator.py\n└── images/                 # Bot UI images\n    ├── bot_avatar.png\n    ├── main_menu.png\n    ├── commands.png\n    ├── my_chats.png\n    └── user_profile.png\n```\n\n## Current State\n- ✅ Fresh GitHub import completed\n- ✅ Security vulnerability in INSTALLATION.md resolved (removed hardcoded credentials)  \n- ✅ Python environment and dependencies installed successfully\n- ✅ Environment variable validation implemented with clear error messages\n- ✅ Bot workflow configured and ready to run\n- ⏳ **Ready for user to provide credentials**: The bot is fully set up and will start once environment variables are configured\n\n## Dependencies\nThe bot requires the following Python packages:\n- aiogram==3.22.0 (Telegram Bot API library)\n- aiosqlite==0.21.0 (Async SQLite database)\n- Pillow==11.3.0 (Image processing)\n- matplotlib==3.10.6 (Graph generation)\n- requests==2.32.5 (HTTP requests)\n- aiofiles==24.1.0 (Async file operations)\n- openai==1.54.4 (OpenAI API for image generation)\n\n## Environment Variables Required\n- BOT_TOKEN: Telegram bot token\n- API_ID: Telegram API ID\n- API_HASH: Telegram API hash\n- OPENAI_API_KEY: OpenAI API key (optional, for image generation)\n\n## Architecture\n- **Backend only**: This is a console application that connects to Telegram API\n- **Database**: Uses SQLite for storing user data, ranks, warnings, and chat information\n- **No frontend**: The bot interface is entirely through Telegram\n- **Async**: Built on asyncio and aiogram for handling multiple users simultaneously\n\n## User Preferences\n- Security-focused: Uses environment variables for sensitive credentials\n- Following existing project structure and conventions\n- Maintaining Russian language support in bot messages","size_bytes":2932},"CustosBot/INSTALLATION.md":{"content":"# Установка Custos Telegram Bot на Linux сервер\n\n## Системные требования\n\n- Linux сервер (Ubuntu/CentOS/Debian)\n- Python 3.8 или выше\n- Доступ к панели управления (ispmanager)\n- Файловый менеджер\n\n## Подготовка файлов\n\n### 1. Структура проекта для загрузки\n\nУбедитесь, что у вас есть следующая структура файлов для загрузки:\n\n```\nCustosBot/\n├── main.py                 # Главный файл запуска\n├── config.py               # Конфигурация бота\n├── handlers/               # Обработчики команд\n│   ├── __init__.py\n│   ├── main_handlers.py\n│   ├── moderation_handlers.py\n│   └── user_handlers.py\n├── keyboards/              # Клавиатуры\n│   └── main_keyboards.py\n├── data/                   # База данных\n│   └── database.py\n├── utils/                  # Утилиты\n│   ├── __init__.py\n│   └── image_generator.py\n├── images/                 # Изображения бота\n│   ├── main_menu.png\n│   ├── commands.png\n│   ├── my_chats.png\n│   ├── user_profile.png\n│   └── bot_avatar.png\n└── requirements.txt        # Зависимости\n```\n\n### 2. Создание файла requirements.txt\n\nСоздайте файл `requirements.txt` в папке CustosBot со следующим содержимым:\n\n```\naiogram==3.22.0\naiosqlite==0.21.0\nPillow==11.3.0\nmatplotlib==3.10.6\nrequests==2.32.5\naiofiles==24.1.0\nopenai==1.54.4\n```\n\n## Установка через ispmanager\n\n### Шаг 1: Загрузка файлов\n\n1. Войдите в ispmanager\n2. Перейдите в раздел \"Файловый менеджер\"\n3. Создайте папку для бота, например: `/home/username/custos_bot/`\n4. Загрузите всю папку `CustosBot` в созданную директорию\n\n### Шаг 2: Настройка окружения через SSH\n\nПодключитесь к серверу через SSH и выполните следующие команды:\n\n```bash\n# Перейдите в директорию с ботом\ncd /home/username/custos_bot/CustosBot\n\n# Обновите систему\nsudo apt update\nsudo apt upgrade -y\n\n# Установите Python и pip (если не установлены)\nsudo apt install python3 python3-pip python3-venv -y\n\n# Создайте виртуальное окружение\npython3 -m venv venv\n\n# Активируйте виртуальное окружение\nsource venv/bin/activate\n\n# Установите зависимости\npip install -r requirements.txt\n\n# Создайте папку для базы данных\nmkdir -p data\n```\n\n### Шаг 3: Настройка API ключей\n\nЕсли вы планируете использовать генерацию изображений через OpenAI:\n\n```bash\n# Экспортируйте API ключи (замените на ваши ключи)\nexport OPENAI_API_KEY=\"your-openai-api-key-here\"\n\n# Для постоянного сохранения добавьте в .bashrc\necho 'export OPENAI_API_KEY=\"your-openai-api-key-here\"' >> ~/.bashrc\n```\n\n### Шаг 4: Проверка конфигурации\n\nУбедитесь, что в файле `config.py` используются переменные окружения для безопасности:\n\n```python\nBOT_TOKEN = os.environ.get(\"BOT_TOKEN\")\nAPI_ID = int(os.environ.get(\"API_ID\", \"0\"))\nAPI_HASH = os.environ.get(\"API_HASH\")\n```\n\nУстановите переменные окружения с вашими реальными значениями:\n\n```bash\nexport BOT_TOKEN=\"your-bot-token-here\"\nexport API_ID=\"your-api-id-here\"\nexport API_HASH=\"your-api-hash-here\"\n```\n\n### Шаг 5: Тестовый запуск\n\n```bash\n# Активируйте виртуальное окружение (если не активировано)\nsource venv/bin/activate\n\n# Запустите бота для тестирования\npython main.py\n```\n\nЕсли бот запустился без ошибок, вы увидите сообщение:\n```\nINFO:__main__:Custos Bot is starting...\nINFO:aiogram.dispatcher:Start polling\nINFO:aiogram.dispatcher:Run polling for bot @custoschatbot id=8356598661 - 'Custos | Чат-менеджер'\n```\n\n## Автозапуск бота\n\n### Создание systemd сервиса\n\n1. Создайте файл сервиса:\n\n```bash\nsudo nano /etc/systemd/system/custos-bot.service\n```\n\n2. Добавьте следующий содержимое:\n\n```ini\n[Unit]\nDescription=Custos Telegram Bot\nAfter=network.target\n\n[Service]\nType=simple\nUser=username\nWorkingDirectory=/home/username/custos_bot/CustosBot\nEnvironment=PATH=/home/username/custos_bot/CustosBot/venv/bin\nEnvironment=BOT_TOKEN=your-bot-token-here\nEnvironment=API_ID=your-api-id-here\nEnvironment=API_HASH=your-api-hash-here\nEnvironment=OPENAI_API_KEY=your-openai-api-key-here\nExecStart=/home/username/custos_bot/CustosBot/venv/bin/python main.py\nRestart=always\nRestartSec=3\n\n[Install]\nWantedBy=multi-user.target\n```\n\n3. Замените `username` на ваше имя пользователя и `your-openai-api-key-here` на ваш API ключ.\n\n4. Активируйте сервис:\n\n```bash\n# Перезагрузите systemd\nsudo systemctl daemon-reload\n\n# Включите автозапуск\nsudo systemctl enable custos-bot.service\n\n# Запустите сервис\nsudo systemctl start custos-bot.service\n\n# Проверьте статус\nsudo systemctl status custos-bot.service\n```\n\n## Управление ботом\n\n### Основные команды\n\n```bash\n# Запуск бота\nsudo systemctl start custos-bot.service\n\n# Остановка бота\nsudo systemctl stop custos-bot.service\n\n# Перезапуск бота\nsudo systemctl restart custos-bot.service\n\n# Просмотр логов\nsudo journalctl -u custos-bot.service -f\n\n# Проверка статуса\nsudo systemctl status custos-bot.service\n```\n\n### Обновление бота\n\n1. Остановите сервис:\n```bash\nsudo systemctl stop custos-bot.service\n```\n\n2. Загрузите новые файлы через ispmanager файловый менеджер\n\n3. Перезапустите сервис:\n```bash\nsudo systemctl start custos-bot.service\n```\n\n## Мониторинг и логи\n\n### Просмотр логов бота\n```bash\n# Текущие логи\nsudo journalctl -u custos-bot.service\n\n# Логи в реальном времени\nsudo journalctl -u custos-bot.service -f\n\n# Последние 100 строк логов\nsudo journalctl -u custos-bot.service -n 100\n```\n\n### Резервное копирование базы данных\n```bash\n# Создание резервной копии\ncp /home/username/custos_bot/CustosBot/data/custos.db /home/username/backup/custos_$(date +%Y%m%d_%H%M%S).db\n```\n\n## Устранение проблем\n\n### Частые ошибки\n\n1. **Бот не отвечает**\n   - Проверьте токен бота в config.py\n   - Убедитесь, что бот запущен: `sudo systemctl status custos-bot.service`\n\n2. **Ошибки модулей Python**\n   - Переустановите зависимости: `pip install -r requirements.txt`\n\n3. **Ошибки базы данных**\n   - Проверьте права доступа к папке data\n   - Убедитесь, что база данных создалась: `ls -la data/`\n\n4. **Ошибки изображений**\n   - Проверьте наличие изображений в папке images/\n   - Убедитесь в правильности OPENAI_API_KEY (если используется)\n\n### Перезапуск бота при ошибках\n```bash\n# Полная перезагрузка\nsudo systemctl stop custos-bot.service\nsleep 5\nsudo systemctl start custos-bot.service\n```\n\n## Контакты и поддержка\n\nЕсли у вас возникли проблемы с установкой или настройкой бота, проверьте:\n\n1. Логи сервиса: `sudo journalctl -u custos-bot.service -f`\n2. Права доступа к файлам\n3. Корректность токенов в config.py\n4. Доступность интернет-соединения\n\nБот готов к работе! Добавьте его в ваши чаты и начните использовать команды управления.","size_bytes":8792},"CustosBot/config.py":{"content":"# Bot configuration\nimport os\n\nBOT_TOKEN = os.environ.get(\"BOT_TOKEN\")\nAPI_ID = int(os.environ.get(\"API_ID\", \"0\"))\nAPI_HASH = os.environ.get(\"API_HASH\")\n\n# Validate required environment variables\nif not BOT_TOKEN:\n    print(\"ERROR: BOT_TOKEN environment variable is required!\")\n    print(\"Please set it using: export BOT_TOKEN='your-bot-token-here'\")\n\nif API_ID == 0:\n    print(\"WARNING: API_ID environment variable is not set or invalid!\")\n    print(\"Please set it using: export API_ID='your-api-id-here'\")\n\nif not API_HASH:\n    print(\"WARNING: API_HASH environment variable is not set!\")\n    print(\"Please set it using: export API_HASH='your-api-hash-here'\")\n\n# Bot commands help text\nBOT_DESCRIPTION = \"\"\"\n🤖 **Custos | Чат-менеджер** — ваш помощник для управления чатами\n\n**Основные функции:**\n• Система рангов (участник → модератор → администратор → владелец)\n• Модерация чата (баны, варны, кики)\n• Персональные профили пользователей\n• Статистика активности чата\n\n**Команды доступны только в групповых чатах!**\n\"\"\"\n\n# Rank system\nRANKS = {\n    'participant': 0,\n    'moderator': 1,\n    'administrator': 2,\n    'owner': 3\n}\n\nRANK_NAMES = {\n    'participant': 'Участник',\n    'moderator': 'Модератор', \n    'administrator': 'Администратор',\n    'owner': 'Владелец'\n}\n\n# Command permissions\nCOMMAND_PERMISSIONS = {\n    'upstaff': ['administrator', 'owner'],\n    'ban': ['administrator', 'owner'],\n    'warn': ['moderator', 'administrator', 'owner'],\n    'kick': ['moderator', 'administrator', 'owner']\n}\n\n# Rate limits (in seconds)\nRATE_LIMITS = {\n    'warn_moderator': 3600,  # 1 hour for moderators\n    'kick_moderator': 900    # 15 minutes for moderators\n}","size_bytes":1942},"CustosBot/main.py":{"content":"import asyncio\nimport logging\nimport os\nfrom aiogram import Bot, Dispatcher\nfrom aiogram.client.default import DefaultBotProperties\nfrom aiogram.enums import ParseMode\n\nfrom handlers import main_handlers, moderation_handlers, user_handlers\nfrom data.database import Database\nfrom config import BOT_TOKEN\n\n# Set up logging\nlogging.basicConfig(level=logging.INFO)\nlogger = logging.getLogger(__name__)\n\nasync def main():\n    \"\"\"Main function to start the bot\"\"\"\n    # Check if BOT_TOKEN is available\n    if not BOT_TOKEN:\n        logger.error(\"BOT_TOKEN is not set! Please configure environment variables.\")\n        logger.error(\"Required environment variables:\")\n        logger.error(\"- BOT_TOKEN: Your Telegram bot token\")\n        logger.error(\"- API_ID: Your Telegram API ID\")\n        logger.error(\"- API_HASH: Your Telegram API hash\")\n        logger.error(\"- OPENAI_API_KEY: Your OpenAI API key (optional)\")\n        return\n    \n    # Initialize bot and dispatcher\n    bot = Bot(\n        token=BOT_TOKEN,\n        default=DefaultBotProperties(parse_mode=ParseMode.HTML)\n    )\n    dp = Dispatcher()\n    \n    # Initialize database\n    db = Database()\n    await db.init_db()\n    \n    # Register routers\n    dp.include_router(main_handlers.router)\n    dp.include_router(moderation_handlers.router)\n    dp.include_router(user_handlers.router)\n    \n    # Create images directory\n    os.makedirs(\"CustosBot/images\", exist_ok=True)\n    \n    logger.info(\"Custos Bot is starting...\")\n    \n    # Start polling\n    try:\n        await dp.start_polling(bot)\n    except Exception as e:\n        logger.error(f\"Bot error: {e}\")\n    finally:\n        await bot.session.close()\n\nif __name__ == \"__main__\":\n    asyncio.run(main())","size_bytes":1708},"CustosBot/data/database.py":{"content":"import aiosqlite\nimport asyncio\nfrom datetime import datetime\nfrom typing import Optional, List, Dict\n\nclass Database:\n    def __init__(self, db_path: str = \"data/custos.db\"):\n        self.db_path = db_path\n    \n    async def init_db(self):\n        \"\"\"Initialize database with required tables\"\"\"\n        async with aiosqlite.connect(self.db_path) as db:\n            # Users table\n            await db.execute(\"\"\"\n                CREATE TABLE IF NOT EXISTS users (\n                    user_id INTEGER PRIMARY KEY,\n                    username TEXT,\n                    first_name TEXT,\n                    last_name TEXT,\n                    nickname TEXT,\n                    description TEXT,\n                    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP\n                )\n            \"\"\")\n            \n            # Chat members table with ranks\n            await db.execute(\"\"\"\n                CREATE TABLE IF NOT EXISTS chat_members (\n                    id INTEGER PRIMARY KEY AUTOINCREMENT,\n                    user_id INTEGER,\n                    chat_id INTEGER,\n                    rank TEXT DEFAULT 'participant',\n                    message_count INTEGER DEFAULT 0,\n                    joined_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,\n                    UNIQUE(user_id, chat_id)\n                )\n            \"\"\")\n            \n            # Warnings table\n            await db.execute(\"\"\"\n                CREATE TABLE IF NOT EXISTS warnings (\n                    id INTEGER PRIMARY KEY AUTOINCREMENT,\n                    user_id INTEGER,\n                    chat_id INTEGER,\n                    reason TEXT,\n                    issued_by INTEGER,\n                    issued_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP\n                )\n            \"\"\")\n            \n            # Chats table\n            await db.execute(\"\"\"\n                CREATE TABLE IF NOT EXISTS chats (\n                    chat_id INTEGER PRIMARY KEY,\n                    title TEXT,\n                    type TEXT,\n                    added_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP\n                )\n            \"\"\")\n            \n            # Message statistics\n            await db.execute(\"\"\"\n                CREATE TABLE IF NOT EXISTS message_stats (\n                    id INTEGER PRIMARY KEY AUTOINCREMENT,\n                    user_id INTEGER,\n                    chat_id INTEGER,\n                    date TEXT,\n                    count INTEGER DEFAULT 1,\n                    UNIQUE(user_id, chat_id, date)\n                )\n            \"\"\")\n            \n            await db.commit()\n    \n    async def add_user(self, user_id: int, username: Optional[str] = None, first_name: Optional[str] = None, last_name: Optional[str] = None):\n        \"\"\"Add or update user in database\"\"\"\n        async with aiosqlite.connect(self.db_path) as db:\n            await db.execute(\"\"\"\n                INSERT OR REPLACE INTO users (user_id, username, first_name, last_name)\n                VALUES (?, ?, ?, ?)\n            \"\"\", (user_id, username, first_name, last_name))\n            await db.commit()\n    \n    async def add_chat_member(self, user_id: int, chat_id: int, rank: str = 'participant'):\n        \"\"\"Add user to chat with specified rank\"\"\"\n        async with aiosqlite.connect(self.db_path) as db:\n            await db.execute(\"\"\"\n                INSERT OR IGNORE INTO chat_members (user_id, chat_id, rank)\n                VALUES (?, ?, ?)\n            \"\"\", (user_id, chat_id, rank))\n            await db.commit()\n    \n    async def update_user_rank(self, user_id: int, chat_id: int, new_rank: str):\n        \"\"\"Update user rank in specific chat\"\"\"\n        async with aiosqlite.connect(self.db_path) as db:\n            await db.execute(\"\"\"\n                UPDATE chat_members SET rank = ? WHERE user_id = ? AND chat_id = ?\n            \"\"\", (new_rank, user_id, chat_id))\n            await db.commit()\n    \n    async def get_user_rank(self, user_id: int, chat_id: int) -> Optional[str]:\n        \"\"\"Get user rank in specific chat\"\"\"\n        async with aiosqlite.connect(self.db_path) as db:\n            cursor = await db.execute(\"\"\"\n                SELECT rank FROM chat_members WHERE user_id = ? AND chat_id = ?\n            \"\"\", (user_id, chat_id))\n            result = await cursor.fetchone()\n            return result[0] if result else None\n    \n    async def add_warning(self, user_id: int, chat_id: int, reason: str, issued_by: int):\n        \"\"\"Add warning to user\"\"\"\n        async with aiosqlite.connect(self.db_path) as db:\n            await db.execute(\"\"\"\n                INSERT INTO warnings (user_id, chat_id, reason, issued_by)\n                VALUES (?, ?, ?, ?)\n            \"\"\", (user_id, chat_id, reason, issued_by))\n            await db.commit()\n    \n    async def get_warning_count(self, user_id: int, chat_id: int) -> int:\n        \"\"\"Get warning count for user in chat\"\"\"\n        async with aiosqlite.connect(self.db_path) as db:\n            cursor = await db.execute(\"\"\"\n                SELECT COUNT(*) FROM warnings WHERE user_id = ? AND chat_id = ?\n            \"\"\", (user_id, chat_id))\n            result = await cursor.fetchone()\n            return result[0] if result else 0\n    \n    async def set_user_nickname(self, user_id: int, nickname: str):\n        \"\"\"Set user nickname\"\"\"\n        async with aiosqlite.connect(self.db_path) as db:\n            await db.execute(\"\"\"\n                UPDATE users SET nickname = ? WHERE user_id = ?\n            \"\"\", (nickname, user_id))\n            await db.commit()\n    \n    async def set_user_description(self, user_id: int, description: str):\n        \"\"\"Set user description\"\"\"\n        async with aiosqlite.connect(self.db_path) as db:\n            await db.execute(\"\"\"\n                UPDATE users SET description = ? WHERE user_id = ?\n            \"\"\", (description, user_id))\n            await db.commit()\n    \n    async def get_user_info(self, user_id: int) -> Optional[Dict]:\n        \"\"\"Get user information\"\"\"\n        async with aiosqlite.connect(self.db_path) as db:\n            cursor = await db.execute(\"\"\"\n                SELECT username, first_name, last_name, nickname, description \n                FROM users WHERE user_id = ?\n            \"\"\", (user_id,))\n            result = await cursor.fetchone()\n            if result:\n                return {\n                    'username': result[0],\n                    'first_name': result[1],\n                    'last_name': result[2],\n                    'nickname': result[3],\n                    'description': result[4]\n                }\n            return None\n    \n    async def get_staff_list(self, chat_id: int) -> Dict[str, List]:\n        \"\"\"Get staff list organized by rank\"\"\"\n        async with aiosqlite.connect(self.db_path) as db:\n            cursor = await db.execute(\"\"\"\n                SELECT u.user_id, u.username, u.first_name, u.nickname, cm.rank\n                FROM users u\n                JOIN chat_members cm ON u.user_id = cm.user_id\n                WHERE cm.chat_id = ? AND cm.rank != 'participant'\n                ORDER BY \n                    CASE cm.rank \n                        WHEN 'owner' THEN 1\n                        WHEN 'administrator' THEN 2\n                        WHEN 'moderator' THEN 3\n                        ELSE 4\n                    END\n            \"\"\", (chat_id,))\n            results = await cursor.fetchall()\n            \n            staff = {'owner': [], 'administrator': [], 'moderator': []}\n            for row in results:\n                user_info = {\n                    'user_id': row[0],\n                    'username': row[1],\n                    'first_name': row[2],\n                    'nickname': row[3]\n                }\n                rank = row[4]\n                if rank in staff:\n                    staff[rank].append(user_info)\n            \n            return staff\n    \n    async def add_chat(self, chat_id: int, title: str, chat_type: str):\n        \"\"\"Add chat to database\"\"\"\n        async with aiosqlite.connect(self.db_path) as db:\n            await db.execute(\"\"\"\n                INSERT OR REPLACE INTO chats (chat_id, title, type)\n                VALUES (?, ?, ?)\n            \"\"\", (chat_id, title, chat_type))\n            await db.commit()\n    \n    async def get_user_chats(self, user_id: int) -> List[Dict]:\n        \"\"\"Get list of chats where user is a member\"\"\"\n        async with aiosqlite.connect(self.db_path) as db:\n            cursor = await db.execute(\"\"\"\n                SELECT c.chat_id, c.title, c.type, cm.rank\n                FROM chats c\n                JOIN chat_members cm ON c.chat_id = cm.chat_id\n                WHERE cm.user_id = ?\n            \"\"\", (user_id,))\n            results = await cursor.fetchall()\n            \n            chats = []\n            for row in results:\n                chats.append({\n                    'chat_id': row[0],\n                    'title': row[1],\n                    'type': row[2],\n                    'rank': row[3]\n                })\n            \n            return chats\n    \n    async def increment_message_count(self, user_id: int, chat_id: int):\n        \"\"\"Increment user message count for today\"\"\"\n        today = datetime.now().strftime('%Y-%m-%d')\n        async with aiosqlite.connect(self.db_path) as db:\n            await db.execute(\"\"\"\n                INSERT OR IGNORE INTO message_stats (user_id, chat_id, date, count)\n                VALUES (?, ?, ?, 1)\n            \"\"\", (user_id, chat_id, today))\n            \n            await db.execute(\"\"\"\n                UPDATE message_stats SET count = count + 1 \n                WHERE user_id = ? AND chat_id = ? AND date = ?\n            \"\"\", (user_id, chat_id, today))\n            \n            await db.execute(\"\"\"\n                UPDATE chat_members SET message_count = message_count + 1\n                WHERE user_id = ? AND chat_id = ?\n            \"\"\", (user_id, chat_id))\n            \n            await db.commit()\n    \n    async def get_user_message_count(self, user_id: int, chat_id: int) -> int:\n        \"\"\"Get total message count for user in chat\"\"\"\n        async with aiosqlite.connect(self.db_path) as db:\n            cursor = await db.execute(\"\"\"\n                SELECT message_count FROM chat_members \n                WHERE user_id = ? AND chat_id = ?\n            \"\"\", (user_id, chat_id))\n            result = await cursor.fetchone()\n            return result[0] if result else 0","size_bytes":10371},"CustosBot/handlers/__init__.py":{"content":"# Handlers package","size_bytes":18},"CustosBot/handlers/main_handlers.py":{"content":"from aiogram import F, Router\nfrom aiogram.types import Message, CallbackQuery, FSInputFile\nfrom aiogram.filters import Command, CommandStart\nimport sys\nimport os\nsys.path.append(os.path.dirname(os.path.dirname(os.path.abspath(__file__))))\n\nfrom keyboards.main_keyboards import get_main_menu_keyboard, get_menu_buttons_keyboard\nfrom data.database import Database\nfrom utils.image_generator import image_gen\nfrom config import BOT_DESCRIPTION\n\nrouter = Router()\ndb = Database()\n\n@router.message(CommandStart())\nasync def start_command(message: Message):\n    \"\"\"Handle /start command\"\"\"\n    user = message.from_user\n    if not user:\n        return\n    \n    # Add user to database\n    await db.add_user(user.id, user.username, user.first_name, user.last_name)\n    \n    # Check if it's a private chat\n    if message.chat.type == 'private':\n        # Generate main menu image if not exists\n        image_path = \"CustosBot/images/main_menu.png\"\n        if not os.path.exists(image_path):\n            try:\n                await image_gen.generate_main_menu_image()\n            except Exception as e:\n                print(f\"Failed to generate main menu image: {e}\")\n        \n        # Send main menu with image\n        try:\n            if os.path.exists(image_path):\n                photo = FSInputFile(image_path)\n                await message.answer_photo(\n                    photo=photo,\n                    caption=BOT_DESCRIPTION,\n                    reply_markup=get_main_menu_keyboard()\n                )\n            else:\n                await message.answer(\n                    BOT_DESCRIPTION,\n                    reply_markup=get_main_menu_keyboard()\n                )\n        except Exception as e:\n            await message.answer(\n                BOT_DESCRIPTION,\n                reply_markup=get_main_menu_keyboard()\n            )\n        \n        # Send menu buttons\n        await message.answer(\n            \"Выберите действие:\",\n            reply_markup=get_menu_buttons_keyboard()\n        )\n    else:\n        # In group chat - add chat and user as member\n        chat = message.chat\n        await db.add_chat(chat.id, chat.title or \"Unknown Chat\", chat.type)\n        await db.add_chat_member(user.id, chat.id)\n        \n        await message.answer(\n            \"👋 Привет! Я Custos - ваш чат-менеджер. Используйте команды для управления чатом!\"\n        )\n\n@router.message(Command(\"help\"))\nasync def help_command(message: Message):\n    \"\"\"Handle /help command\"\"\"\n    # Generate commands image if not exists\n    image_path = \"CustosBot/images/commands.png\"\n    if not os.path.exists(image_path):\n        try:\n            await image_gen.generate_commands_image()\n        except Exception as e:\n            print(f\"Failed to generate commands image: {e}\")\n    \n    help_text = \"\"\"\n📋 **Команды бота**\n\n**Модерация (только в чатах):**\n• `/upstaff [число] [пользователь]` - повысить ранг\n• `/ban [пользователь] [причина]` - забанить\n• `/warn [пользователь] [причина]` - выдать варн\n• `/kick [пользователь] [причина]` - кикнуть\n• `/staff` - список персонала\n\n**Профиль:**\n• `/me` или `кто я` - моя информация\n• `/you [пользователь]` или `кто ты` - информация о пользователе\n• `/nickname +имя` - установить никнейм\n• `/description +описание` - установить описание\n\nПолный список команд в нашей [статье](https://teletype.in/@unisonqq/custoscommands)\n\"\"\"\n    \n    try:\n        if os.path.exists(image_path):\n            photo = FSInputFile(image_path)\n            await message.answer_photo(\n                photo=photo,\n                caption=help_text,\n                parse_mode=\"Markdown\"\n            )\n        else:\n            await message.answer(help_text, parse_mode=\"Markdown\")\n    except Exception as e:\n        await message.answer(help_text, parse_mode=\"Markdown\")\n\n@router.message(F.text == \"💬 Мои чаты\")\nasync def my_chats_command(message: Message):\n    \"\"\"Handle 'My Chats' button\"\"\"\n    user = message.from_user\n    if not user:\n        return\n    \n    # Only work in private chat\n    if message.chat.type != 'private':\n        return\n    \n    # Generate my chats image if not exists\n    image_path = \"CustosBot/images/my_chats.png\"\n    if not os.path.exists(image_path):\n        try:\n            await image_gen.generate_my_chats_image()\n        except Exception as e:\n            print(f\"Failed to generate my chats image: {e}\")\n    \n    # Get user's chats\n    chats = await db.get_user_chats(user.id)\n    \n    if not chats:\n        await message.answer(\"📭 Вы не состоите ни в одном чате с ботом.\")\n        return\n    \n    # Build chat list\n    chat_text = \"💬 **Мои чаты:**\\n\\n\"\n    for chat in chats:\n        chat_id = chat['chat_id']\n        title = chat['title']\n        rank = chat['rank']\n        \n        # Create chat link (negative ID for groups)\n        if chat_id < 0:\n            chat_link = f\"https://t.me/c/{str(chat_id)[4:]}/1\"  # Remove -100 prefix\n        else:\n            chat_link = f\"https://t.me/{chat_id}\"\n        \n        chat_text += f\"• [{title}]({chat_link}) - {rank}\\n\"\n    \n    try:\n        if os.path.exists(image_path):\n            photo = FSInputFile(image_path)\n            await message.answer_photo(\n                photo=photo,\n                caption=chat_text,\n                parse_mode=\"Markdown\"\n            )\n        else:\n            await message.answer(chat_text, parse_mode=\"Markdown\")\n    except Exception as e:\n        await message.answer(chat_text, parse_mode=\"Markdown\")\n\n@router.message(F.text == \"📋 Команды\")\nasync def commands_button(message: Message):\n    \"\"\"Handle 'Commands' button\"\"\"\n    await help_command(message)","size_bytes":6061},"CustosBot/handlers/moderation_handlers.py":{"content":"from aiogram import F, Router\nfrom aiogram.types import Message, CallbackQuery\nfrom aiogram.filters import Command\nfrom data.database import Database\nfrom config import RANKS, RANK_NAMES, COMMAND_PERMISSIONS, RATE_LIMITS\nfrom keyboards.main_keyboards import get_confirmation_keyboard\nimport re\nfrom datetime import datetime, timedelta\n\nrouter = Router()\ndb = Database()\n\n# Rate limit storage (in production, use Redis or database)\nrate_limits = {}\n\nasync def check_rate_limit(user_id: int, command: str, rank: str) -> bool:\n    \"\"\"Check if user is rate limited for command\"\"\"\n    if rank in ['administrator', 'owner']:\n        return True  # No rate limits for high ranks\n    \n    limit_key = f\"{user_id}_{command}\"\n    current_time = datetime.now()\n    \n    if limit_key in rate_limits:\n        last_used = rate_limits[limit_key]\n        if command == 'warn' and rank == 'moderator':\n            if current_time - last_used < timedelta(seconds=RATE_LIMITS['warn_moderator']):\n                return False\n        elif command == 'kick' and rank == 'moderator':\n            if current_time - last_used < timedelta(seconds=RATE_LIMITS['kick_moderator']):\n                return False\n    \n    rate_limits[limit_key] = current_time\n    return True\n\nasync def get_target_user(message: Message, text: str) -> tuple[int, str]:\n    \"\"\"Extract target user from command\"\"\"\n    # Check if it's a reply\n    if message.reply_to_message and message.reply_to_message.from_user:\n        user = message.reply_to_message.from_user\n        return user.id, user.first_name or user.username or str(user.id)\n    \n    # Parse username or user ID from text\n    words = text.split()[2:]  # Skip command and number if present\n    if words:\n        target = words[0]\n        if target.startswith('@'):\n            # Username - in real implementation, you'd need to resolve this\n            return 0, target  # Placeholder\n        elif target.isdigit():\n            return int(target), target\n    \n    return 0, \"\"\n\n@router.message(Command(\"upstaff\"))\nasync def upstaff_command(message: Message):\n    \"\"\"Handle /upstaff command for rank promotion\"\"\"\n    user = message.from_user\n    chat = message.chat\n    \n    if not user or chat.type == 'private':\n        await message.answer(\"❌ Команда доступна только в групповых чатах!\")\n        return\n    \n    # Get user rank\n    user_rank = await db.get_user_rank(user.id, chat.id)\n    if not user_rank or user_rank not in COMMAND_PERMISSIONS['upstaff']:\n        await message.answer(\"❌ Слишком низкий ранг для использования этой команды!\")\n        return\n    \n    # Parse command: /upstaff [число] [пользователь]\n    text = message.text or \"\"\n    parts = text.split()\n    \n    if len(parts) < 3:\n        await message.answer(\"❌ Использование: `/upstaff [число] [пользователь]`\", parse_mode=\"Markdown\")\n        return\n    \n    try:\n        rank_increase = int(parts[1])\n    except ValueError:\n        await message.answer(\"❌ Укажите корректное число для повышения ранга!\")\n        return\n    \n    # Get target user\n    target_user_id, target_name = await get_target_user(message, text)\n    if not target_user_id:\n        await message.answer(\"❌ Не удалось найти указанного пользователя!\")\n        return\n    \n    # Get target user current rank\n    target_rank = await db.get_user_rank(target_user_id, chat.id)\n    if not target_rank:\n        await message.answer(\"❌ Пользователь не найден в чате!\")\n        return\n    \n    current_rank_level = RANKS[target_rank]\n    new_rank_level = min(current_rank_level + rank_increase, 3)  # Max is owner (3)\n    \n    # Find new rank name\n    new_rank = None\n    for rank_name, level in RANKS.items():\n        if level == new_rank_level:\n            new_rank = rank_name\n            break\n    \n    if not new_rank or new_rank == target_rank:\n        await message.answer(\"❌ Невозможно повысить до указанного ранга!\")\n        return\n    \n    # Permission check\n    if user_rank == 'administrator' and target_rank == 'owner':\n        await message.answer(\"❌ Администратор не может повышать владельца!\")\n        return\n    \n    # Special confirmation for promoting to owner\n    if new_rank == 'owner' and user_rank == 'owner':\n        keyboard = get_confirmation_keyboard(\"promote_owner\", target_user_id)\n        await message.answer(\n            f\"⚠️ Вы собираетесь передать права владельца пользователю {target_name}. Подтвердите действие:\",\n            reply_markup=keyboard\n        )\n        return\n    \n    # Perform promotion\n    await db.update_user_rank(target_user_id, chat.id, new_rank)\n    \n    await message.answer(\n        f\"✅ {target_name} повышен в ранге, теперь он {RANK_NAMES[new_rank]}!\"\n    )\n\n@router.callback_query(F.data.startswith(\"confirm_promote_owner_\"))\nasync def confirm_owner_promotion(callback: CallbackQuery):\n    \"\"\"Handle owner promotion confirmation\"\"\"\n    user = callback.from_user\n    chat = callback.message.chat if callback.message else None\n    \n    if not user or not chat:\n        return\n    \n    # Check if user is owner\n    user_rank = await db.get_user_rank(user.id, chat.id)\n    if user_rank != 'owner':\n        await callback.answer(\"🚫 Эта кнопка не для вас ^-^\", show_alert=True)\n        return\n    \n    # Extract target user ID\n    if callback.data:\n        target_user_id = int(callback.data.split(\"_\")[-1])\n    else:\n        await callback.answer(\"❌ Ошибка данных\", show_alert=True)\n        return\n    \n    # Perform promotion\n    await db.update_user_rank(target_user_id, chat.id, 'owner')\n    await db.update_user_rank(user.id, chat.id, 'administrator')  # Demote current owner\n    \n    if callback.message and hasattr(callback.message, 'edit_text'):\n        await callback.message.edit_text(\"✅ Права владельца успешно переданы!\")\n    await callback.answer()\n\n@router.message(Command(\"ban\"))\nasync def ban_command(message: Message):\n    \"\"\"Handle /ban command\"\"\"\n    user = message.from_user\n    chat = message.chat\n    \n    if not user or chat.type == 'private':\n        await message.answer(\"❌ Команда доступна только в групповых чатах!\")\n        return\n    \n    # Check permissions\n    user_rank = await db.get_user_rank(user.id, chat.id)\n    if not user_rank or user_rank not in COMMAND_PERMISSIONS['ban']:\n        await message.answer(\"❌ Недостаточно прав для использования этой команды!\")\n        return\n    \n    text = message.text or \"\"\n    parts = text.split(maxsplit=2)\n    \n    if len(parts) < 3:\n        await message.answer(\"❌ Использование: `/ban [пользователь] [причина]`\", parse_mode=\"Markdown\")\n        return\n    \n    target_user_id, target_name = await get_target_user(message, text)\n    reason = parts[2] if len(parts) > 2 else \"Нарушение правил\"\n    \n    if not target_user_id:\n        await message.answer(\"❌ Не удалось найти указанного пользователя!\")\n        return\n    \n    try:\n        # Try to ban user from chat\n        await message.chat.ban(target_user_id)\n        await message.answer(f\"🚫 {target_name} исключен из чата.\\nПричина: {reason}\")\n    except Exception as e:\n        await message.answer(f\"❌ Не удалось забанить пользователя: {str(e)}\")\n\n@router.message(Command(\"warn\"))\nasync def warn_command(message: Message):\n    \"\"\"Handle /warn command\"\"\"\n    user = message.from_user\n    chat = message.chat\n    \n    if not user or chat.type == 'private':\n        await message.answer(\"❌ Команда доступна только в групповых чатах!\")\n        return\n    \n    # Check permissions\n    user_rank = await db.get_user_rank(user.id, chat.id)\n    if not user_rank or user_rank not in COMMAND_PERMISSIONS['warn']:\n        await message.answer(\"❌ Недостаточно прав для использования этой команды!\")\n        return\n    \n    # Check rate limit\n    if not await check_rate_limit(user.id, 'warn', user_rank):\n        await message.answer(\"⏰ Вы можете использовать эту команду раз в час!\")\n        return\n    \n    text = message.text or \"\"\n    parts = text.split(maxsplit=2)\n    \n    if len(parts) < 3:\n        await message.answer(\"❌ Использование: `/warn [пользователь] [причина]`\", parse_mode=\"Markdown\")\n        return\n    \n    target_user_id, target_name = await get_target_user(message, text)\n    reason = parts[2] if len(parts) > 2 else \"Нарушение правил\"\n    \n    if not target_user_id:\n        await message.answer(\"❌ Не удалось найти указанного пользователя!\")\n        return\n    \n    # Add warning\n    await db.add_warning(target_user_id, chat.id, reason, user.id)\n    \n    # Check warning count\n    warning_count = await db.get_warning_count(target_user_id, chat.id)\n    \n    if warning_count >= 5:\n        try:\n            await message.chat.ban(target_user_id)\n            await message.answer(f\"🚫 {target_name} получил 5-й варн и автоматически забанен!\")\n        except Exception as e:\n            await message.answer(f\"⚠️ {target_name} получил {warning_count}-й варн! Причина: {reason}\")\n    else:\n        await message.answer(f\"⚠️ {target_name} получил варн ({warning_count}/5). Причина: {reason}\")\n\n@router.message(Command(\"kick\"))\nasync def kick_command(message: Message):\n    \"\"\"Handle /kick command\"\"\"\n    user = message.from_user\n    chat = message.chat\n    \n    if not user or chat.type == 'private':\n        await message.answer(\"❌ Команда доступна только в групповых чатах!\")\n        return\n    \n    # Check permissions\n    user_rank = await db.get_user_rank(user.id, chat.id)\n    if not user_rank or user_rank not in COMMAND_PERMISSIONS['kick']:\n        await message.answer(\"❌ Недостаточно прав для использования этой команды!\")\n        return\n    \n    # Check rate limit\n    if not await check_rate_limit(user.id, 'kick', user_rank):\n        await message.answer(\"⏰ Модератор может использовать эту команду раз в 15 минут!\")\n        return\n    \n    text = message.text or \"\"\n    parts = text.split(maxsplit=2)\n    \n    if len(parts) < 3:\n        await message.answer(\"❌ Использование: `/kick [пользователь] [причина]`\", parse_mode=\"Markdown\")\n        return\n    \n    target_user_id, target_name = await get_target_user(message, text)\n    reason = parts[2] if len(parts) > 2 else \"Нарушение правил\"\n    \n    if not target_user_id:\n        await message.answer(\"❌ Не удалось найти указанного пользователя!\")\n        return\n    \n    try:\n        # Kick user (unban immediately after ban)\n        await message.chat.ban(target_user_id)\n        await message.chat.unban(target_user_id)\n        await message.answer(f\"👢 {target_name} исключен из чата временно.\\nПричина: {reason}\")\n    except Exception as e:\n        await message.answer(f\"❌ Не удалось кикнуть пользователя: {str(e)}\")\n\n@router.message(Command(\"staff\"))\nasync def staff_command(message: Message):\n    \"\"\"Handle /staff command\"\"\"\n    chat = message.chat\n    \n    if chat.type == 'private':\n        await message.answer(\"❌ Команда доступна только в групповых чатах!\")\n        return\n    \n    # Get staff list\n    staff = await db.get_staff_list(chat.id)\n    \n    staff_text = \"👥 **Персонал чата:**\\n\\n\"\n    \n    # Owners\n    if staff['owner']:\n        staff_text += \"👑 **Владельцы:**\\n\"\n        for member in staff['owner']:\n            name = member['nickname'] or member['first_name'] or member['username'] or str(member['user_id'])\n            staff_text += f\"• {name}\\n\"\n        staff_text += \"\\n\"\n    \n    # Administrators\n    if staff['administrator']:\n        staff_text += \"⭐ **Администраторы:**\\n\"\n        for member in staff['administrator']:\n            name = member['nickname'] or member['first_name'] or member['username'] or str(member['user_id'])\n            staff_text += f\"• {name}\\n\"\n        staff_text += \"\\n\"\n    \n    # Moderators\n    if staff['moderator']:\n        staff_text += \"🛡 **Модераторы:**\\n\"\n        for member in staff['moderator']:\n            name = member['nickname'] or member['first_name'] or member['username'] or str(member['user_id'])\n            staff_text += f\"• {name}\\n\"\n    \n    if not any(staff.values()):\n        staff_text += \"Персонал не назначен.\"\n    \n    await message.answer(staff_text, parse_mode=\"Markdown\")","size_bytes":13353},"CustosBot/handlers/user_handlers.py":{"content":"from aiogram import F, Router\nfrom aiogram.types import Message, FSInputFile\nfrom aiogram.filters import Command\nfrom data.database import Database\nfrom utils.image_generator import image_gen\nfrom config import RANK_NAMES\nimport os\n\nrouter = Router()\ndb = Database()\n\nasync def get_target_user_for_profile(message: Message) -> tuple[int, str]:\n    \"\"\"Get target user for profile commands\"\"\"\n    # Check if it's a reply\n    if message.reply_to_message and message.reply_to_message.from_user:\n        user = message.reply_to_message.from_user\n        return user.id, user.first_name or user.username or str(user.id)\n    \n    # Parse username from command\n    text = message.text or \"\"\n    parts = text.split()\n    if len(parts) > 1:\n        target = parts[1]\n        if target.startswith('@'):\n            # In real implementation, resolve username\n            return 0, target\n        elif target.isdigit():\n            return int(target), target\n    \n    return 0, \"\"\n\n@router.message(Command(\"me\"))\n@router.message(F.text.lower() == \"кто я\")\nasync def me_command(message: Message):\n    \"\"\"Handle /me and 'кто я' commands\"\"\"\n    user = message.from_user\n    chat = message.chat\n    \n    if not user or chat.type == 'private':\n        await message.answer(\"❌ Команда доступна только в групповых чатах!\")\n        return\n    \n    # Generate user profile image if not exists\n    image_path = \"CustosBot/images/user_profile.png\"\n    if not os.path.exists(image_path):\n        try:\n            await image_gen.generate_user_profile_image()\n        except Exception as e:\n            print(f\"Failed to generate user profile image: {e}\")\n    \n    # Get user info\n    user_info = await db.get_user_info(user.id)\n    user_rank = await db.get_user_rank(user.id, chat.id)\n    message_count = await db.get_user_message_count(user.id, chat.id)\n    \n    # Build profile text\n    display_name = (user_info['nickname'] if user_info and user_info['nickname'] \n                   else user.first_name or user.username or str(user.id))\n    \n    profile_text = f\"👤 **Описание чатера**\\n\\n\"\n    profile_text += f\"**Имя:** {display_name}\\n\"\n    profile_text += f\"**Ссылка:** [Профиль](tg://user?id={user.id})\\n\"\n    profile_text += f\"**Сообщений:** {message_count}\\n\"\n    profile_text += f\"**Ранг:** {RANK_NAMES.get(user_rank, 'Неизвестен')}\\n\"\n    \n    if user_info and user_info['description']:\n        profile_text += f\"**Описание:** {user_info['description']}\\n\"\n    else:\n        profile_text += \"**Описание:** не установлено\\n\"\n    \n    try:\n        if os.path.exists(image_path):\n            photo = FSInputFile(image_path)\n            await message.answer_photo(\n                photo=photo,\n                caption=profile_text,\n                parse_mode=\"Markdown\"\n            )\n        else:\n            await message.answer(profile_text, parse_mode=\"Markdown\")\n    except Exception as e:\n        await message.answer(profile_text, parse_mode=\"Markdown\")\n\n@router.message(Command(\"you\"))\n@router.message(F.text.lower() == \"кто ты\")\nasync def you_command(message: Message):\n    \"\"\"Handle /you and 'кто ты' commands\"\"\"\n    user = message.from_user\n    chat = message.chat\n    \n    if not user or chat.type == 'private':\n        await message.answer(\"❌ Команда доступна только в групповых чатах!\")\n        return\n    \n    # Get target user\n    target_user_id, target_name = await get_target_user_for_profile(message)\n    \n    if not target_user_id:\n        await message.answer(\"❌ Укажите пользователя: `/you @username` или ответьте на сообщение\", parse_mode=\"Markdown\")\n        return\n    \n    # Generate user profile image if not exists\n    image_path = \"CustosBot/images/user_profile.png\"\n    if not os.path.exists(image_path):\n        try:\n            await image_gen.generate_user_profile_image()\n        except Exception as e:\n            print(f\"Failed to generate user profile image: {e}\")\n    \n    # Get user info\n    user_info = await db.get_user_info(target_user_id)\n    user_rank = await db.get_user_rank(target_user_id, chat.id)\n    message_count = await db.get_user_message_count(target_user_id, chat.id)\n    \n    if not user_rank:\n        await message.answer(\"❌ Пользователь не найден в чате!\")\n        return\n    \n    # Build profile text\n    display_name = (user_info['nickname'] if user_info and user_info['nickname'] \n                   else target_name)\n    \n    profile_text = f\"👤 **Описание чатера**\\n\\n\"\n    profile_text += f\"**Имя:** {display_name}\\n\"\n    profile_text += f\"**Ссылка:** [Профиль](tg://user?id={target_user_id})\\n\"\n    profile_text += f\"**Сообщений:** {message_count}\\n\"\n    profile_text += f\"**Ранг:** {RANK_NAMES.get(user_rank, 'Неизвестен')}\\n\"\n    \n    if user_info and user_info['description']:\n        profile_text += f\"**Описание:** {user_info['description']}\\n\"\n    else:\n        profile_text += \"**Описание:** не установлено\\n\"\n    \n    try:\n        if os.path.exists(image_path):\n            photo = FSInputFile(image_path)\n            await message.answer_photo(\n                photo=photo,\n                caption=profile_text,\n                parse_mode=\"Markdown\"\n            )\n        else:\n            await message.answer(profile_text, parse_mode=\"Markdown\")\n    except Exception as e:\n        await message.answer(profile_text, parse_mode=\"Markdown\")\n\n@router.message(Command(\"nickname\"))\n@router.message(F.text.startswith(\"+ник \"))\n@router.message(F.text.startswith(\"+имя \"))\nasync def nickname_command(message: Message):\n    \"\"\"Handle nickname setting commands\"\"\"\n    user = message.from_user\n    chat = message.chat\n    \n    if not user or chat.type == 'private':\n        await message.answer(\"❌ Команда доступна только в групповых чатах!\")\n        return\n    \n    text = message.text or \"\"\n    \n    # Parse nickname from different command formats\n    nickname = \"\"\n    if text.startswith(\"/nickname \"):\n        nickname = text[10:].strip()\n    elif text.startswith(\"+ник \"):\n        nickname = text[5:].strip()\n    elif text.startswith(\"+имя \"):\n        nickname = text[5:].strip()\n    \n    if not nickname:\n        await message.answer(\"❌ Укажите никнейм: `/nickname ВашНикнейм`\", parse_mode=\"Markdown\")\n        return\n    \n    if len(nickname) > 50:\n        await message.answer(\"❌ Никнейм не может быть длиннее 50 символов!\")\n        return\n    \n    # Set nickname\n    await db.set_user_nickname(user.id, nickname)\n    await message.answer(f\"✅ Никнейм установлен: **{nickname}**\", parse_mode=\"Markdown\")\n\n@router.message(Command(\"description\"))\n@router.message(F.text.startswith(\"+опис \"))\n@router.message(F.text.startswith(\"+описание \"))\nasync def description_command(message: Message):\n    \"\"\"Handle description setting commands\"\"\"\n    user = message.from_user\n    chat = message.chat\n    \n    if not user or chat.type == 'private':\n        await message.answer(\"❌ Команда доступна только в групповых чатах!\")\n        return\n    \n    text = message.text or \"\"\n    \n    # Parse description from different command formats\n    description = \"\"\n    if text.startswith(\"/description \"):\n        description = text[13:].strip()\n    elif text.startswith(\"+опис \"):\n        description = text[6:].strip()\n    elif text.startswith(\"+описание \"):\n        description = text[10:].strip()\n    \n    if not description:\n        await message.answer(\"❌ Укажите описание: `/description Ваше описание`\", parse_mode=\"Markdown\")\n        return\n    \n    if len(description) > 200:\n        await message.answer(\"❌ Описание не может быть длиннее 200 символов!\")\n        return\n    \n    # Set description\n    await db.set_user_description(user.id, description)\n    await message.answer(f\"✅ Описание установлено: **{description}**\", parse_mode=\"Markdown\")\n\n@router.message(F.content_type == \"text\")\nasync def track_messages(message: Message):\n    \"\"\"Track user messages for statistics\"\"\"\n    user = message.from_user\n    chat = message.chat\n    \n    if not user or chat.type == 'private':\n        return\n    \n    # Add user and chat if not exists\n    await db.add_user(user.id, user.username, user.first_name, user.last_name)\n    await db.add_chat(chat.id, chat.title or \"Unknown Chat\", chat.type)\n    await db.add_chat_member(user.id, chat.id)\n    \n    # Increment message count\n    await db.increment_message_count(user.id, chat.id)","size_bytes":8876},"CustosBot/keyboards/main_keyboards.py":{"content":"from aiogram.types import InlineKeyboardMarkup, InlineKeyboardButton, ReplyKeyboardMarkup, KeyboardButton\n\ndef get_main_menu_keyboard() -> InlineKeyboardMarkup:\n    \"\"\"Main menu keyboard with 'Add to chat' button\"\"\"\n    keyboard = InlineKeyboardMarkup(inline_keyboard=[\n        [InlineKeyboardButton(text=\"➕ Добавить в чат\", url=\"https://t.me/custoschatbot?startgroup=true\")]\n    ])\n    return keyboard\n\ndef get_menu_buttons_keyboard() -> ReplyKeyboardMarkup:\n    \"\"\"Regular keyboard with menu buttons\"\"\"\n    keyboard = ReplyKeyboardMarkup(\n        keyboard=[\n            [KeyboardButton(text=\"💬 Мои чаты\")],\n            [KeyboardButton(text=\"📋 Команды\")]\n        ],\n        resize_keyboard=True,\n        persistent=True\n    )\n    return keyboard\n\ndef get_confirmation_keyboard(action: str, target_user_id: int) -> InlineKeyboardMarkup:\n    \"\"\"Confirmation keyboard for sensitive actions like promoting to owner\"\"\"\n    keyboard = InlineKeyboardMarkup(inline_keyboard=[\n        [InlineKeyboardButton(text=\"✅ Подтвердить\", callback_data=f\"confirm_{action}_{target_user_id}\")]\n    ])\n    return keyboard\n\ndef get_back_keyboard() -> InlineKeyboardMarkup:\n    \"\"\"Simple back button\"\"\"\n    keyboard = InlineKeyboardMarkup(inline_keyboard=[\n        [InlineKeyboardButton(text=\"🔙 Назад\", callback_data=\"back_to_menu\")]\n    ])\n    return keyboard","size_bytes":1392},"CustosBot/utils/__init__.py":{"content":"# Utils package","size_bytes":15},"CustosBot/utils/image_generator.py":{"content":"import os\nimport asyncio\nimport requests\nfrom PIL import Image, ImageDraw, ImageFont\nfrom io import BytesIO\nfrom openai import OpenAI\n\n# the newest OpenAI model is \"gpt-5\" which was released August 7, 2025.\n# do not change this unless explicitly requested by the user\n\nclass ImageGenerator:\n    def __init__(self):\n        self.openai_client = None\n        self.images_path = \"CustosBot/images\"\n        os.makedirs(self.images_path, exist_ok=True)\n        \n        # Initialize OpenAI client only if API key is available\n        openai_api_key = os.environ.get(\"OPENAI_API_KEY\")\n        if openai_api_key:\n            try:\n                self.openai_client = OpenAI(api_key=openai_api_key)\n            except Exception as e:\n                print(f\"Failed to initialize OpenAI client: {e}\")\n                self.openai_client = None\n    \n    async def generate_with_openai(self, prompt: str, filename: str) -> str:\n        \"\"\"Generate image using OpenAI DALL-E\"\"\"\n        # If OpenAI client is not available, fallback to local generation\n        if not self.openai_client:\n            print(\"OpenAI client not available, using local generation\")\n            return await self.generate_local(prompt, filename)\n            \n        try:\n            response = self.openai_client.images.generate(\n                model=\"dall-e-3\",\n                prompt=prompt,\n                n=1,\n                size=\"1024x1024\"\n            )\n            \n            # Download the image\n            if response.data and len(response.data) > 0:\n                image_url = response.data[0].url\n                if image_url:\n                    image_response = requests.get(image_url)\n                else:\n                    raise Exception(\"No image URL received from OpenAI\")\n            else:\n                raise Exception(\"No image data received from OpenAI\")\n            \n            if image_response.status_code == 200:\n                filepath = os.path.join(self.images_path, filename)\n                with open(filepath, 'wb') as f:\n                    f.write(image_response.content)\n                return filepath\n            else:\n                raise Exception(f\"Failed to download image: {image_response.status_code}\")\n                \n        except Exception as e:\n            print(f\"OpenAI generation failed: {e}\")\n            # Fallback to local generation\n            return await self.generate_local(prompt, filename)\n    \n    async def generate_local(self, text: str, filename: str) -> str:\n        \"\"\"Generate image locally using PIL as fallback\"\"\"\n        try:\n            # Create dark themed image\n            width, height = 1024, 1024\n            background_color = (30, 20, 60)  # Dark purple\n            text_color = (255, 255, 255)     # White text\n            accent_color = (138, 43, 226)    # Blue violet\n            \n            image = Image.new('RGB', (width, height), background_color)\n            draw = ImageDraw.Draw(image)\n            \n            # Try to use a nice font, fallback to default\n            try:\n                font_size = 80\n                font = ImageFont.truetype(\"/usr/share/fonts/truetype/dejavu/DejaVuSans-Bold.ttf\", font_size)\n            except:\n                font = ImageFont.load_default()\n            \n            # Calculate text position\n            bbox = draw.textbbox((0, 0), text, font=font)\n            text_width = bbox[2] - bbox[0]\n            text_height = bbox[3] - bbox[1]\n            \n            x = (width - text_width) // 2\n            y = (height - text_height) // 2\n            \n            # Draw accent background\n            margin = 50\n            draw.rectangle([x-margin, y-margin, x+text_width+margin, y+text_height+margin], \n                         fill=accent_color, outline=None)\n            \n            # Draw text\n            draw.text((x, y), text, fill=text_color, font=font)\n            \n            # Add decorative elements\n            for i in range(5):\n                circle_x = 100 + i * 200\n                circle_y = 100\n                draw.ellipse([circle_x-10, circle_y-10, circle_x+10, circle_y+10], \n                           fill=accent_color)\n            \n            filepath = os.path.join(self.images_path, filename)\n            image.save(filepath)\n            return filepath\n            \n        except Exception as e:\n            print(f\"Local generation failed: {e}\")\n            # Return a basic placeholder path\n            return os.path.join(self.images_path, filename)\n    \n    async def generate_main_menu_image(self) -> str:\n        \"\"\"Generate main menu cover image\"\"\"\n        prompt = \"\"\"\n        Dark themed logo for Telegram bot called 'Custos | Чат-менеджер'. \n        Modern minimalist design with dark purple, blue, black and white colors. \n        Dark background with elegant white text. \n        Futuristic chat management theme with geometric elements.\n        No realistic photos, just abstract geometric design.\n        \"\"\"\n        return await self.generate_with_openai(prompt, \"main_menu.png\")\n    \n    async def generate_commands_image(self) -> str:\n        \"\"\"Generate commands help image\"\"\"\n        prompt = \"\"\"\n        Dark themed header image with text 'Команды' (Commands in Russian). \n        Dark purple and blue gradient background with white text. \n        Minimalist design with geometric elements and chat symbols.\n        Modern tech style, no realistic photos.\n        \"\"\"\n        return await self.generate_with_openai(prompt, \"commands.png\")\n    \n    async def generate_my_chats_image(self) -> str:\n        \"\"\"Generate my chats image\"\"\"\n        prompt = \"\"\"\n        Dark themed header image with text 'Мои чаты' (My Chats in Russian). \n        Dark background with purple and blue accents. \n        Chat bubble icons and geometric elements. \n        Modern minimalist style, white text on dark background.\n        \"\"\"\n        return await self.generate_with_openai(prompt, \"my_chats.png\")\n    \n    async def generate_user_profile_image(self) -> str:\n        \"\"\"Generate user profile description image\"\"\"\n        prompt = \"\"\"\n        Dark themed image for user profile with text 'Описание чатера' (User Description in Russian).\n        Dark purple background with blue accents. \n        User avatar placeholder and profile elements.\n        Modern minimalist design with white text.\n        \"\"\"\n        return await self.generate_with_openai(prompt, \"user_profile.png\")\n    \n    async def generate_bot_avatar(self) -> str:\n        \"\"\"Generate bot avatar\"\"\"\n        prompt = \"\"\"\n        Bot avatar for 'Custos' chat manager. \n        Circular avatar with dark theme - purple, blue, black colors. \n        Modern robotic or AI assistant appearance. \n        Professional and trustworthy design. \n        No text, just the avatar icon.\n        \"\"\"\n        return await self.generate_with_openai(prompt, \"bot_avatar.png\")\n\n# Create global instance\nimage_gen = ImageGenerator()","size_bytes":6972}},"version":1}