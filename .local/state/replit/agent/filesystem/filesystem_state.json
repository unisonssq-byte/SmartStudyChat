{"file_contents":{"pyproject.toml":{"content":"[project]\nname = \"repl-nix-workspace\"\nversion = \"0.1.0\"\ndescription = \"Add your description here\"\nrequires-python = \">=3.11\"\ndependencies = [\n    \"aiofiles>=24.1.0\",\n    \"aiogram>=3.22.0\",\n    \"aiosqlite>=0.21.0\",\n    \"matplotlib>=3.10.6\",\n    \"openai>=1.108.1\",\n    \"pillow>=11.3.0\",\n    \"requests>=2.32.5\",\n]\n","size_bytes":311},"replit.md":{"content":"# Custos Telegram Bot | –ß–∞—Ç-–º–µ–Ω–µ–¥–∂–µ—Ä\n\n## Overview\nThis is a Python Telegram bot project called \"Custos | –ß–∞—Ç-–º–µ–Ω–µ–¥–∂–µ—Ä\" - a simplified chat management bot built with aiogram. The bot provides moderation features, user ranking system, and various administrative commands for Telegram group chats.\n\n## Project Structure\n```\nCustosBot/\n‚îú‚îÄ‚îÄ main.py                 # Main bot entry point\n‚îú‚îÄ‚îÄ config.py               # Bot configuration and settings\n‚îú‚îÄ‚îÄ requirements.txt        # Python dependencies\n‚îú‚îÄ‚îÄ INSTALLATION.md        # Server installation guide\n‚îú‚îÄ‚îÄ handlers/               # Command handlers\n‚îÇ   ‚îú‚îÄ‚îÄ __init__.py\n‚îÇ   ‚îú‚îÄ‚îÄ main_handlers.py\n‚îÇ   ‚îú‚îÄ‚îÄ moderation_handlers.py\n‚îÇ   ‚îî‚îÄ‚îÄ user_handlers.py\n‚îú‚îÄ‚îÄ keyboards/              # Bot keyboards and buttons\n‚îÇ   ‚îî‚îÄ‚îÄ main_keyboards.py\n‚îú‚îÄ‚îÄ data/                   # Database and data management\n‚îÇ   ‚îú‚îÄ‚îÄ database.py         # Database class and operations\n‚îÇ   ‚îî‚îÄ‚îÄ custos.db          # SQLite database file\n‚îú‚îÄ‚îÄ utils/                  # Utility functions\n‚îÇ   ‚îú‚îÄ‚îÄ __init__.py\n‚îÇ   ‚îî‚îÄ‚îÄ image_generator.py\n‚îî‚îÄ‚îÄ images/                 # Bot UI images\n    ‚îú‚îÄ‚îÄ bot_avatar.png\n    ‚îú‚îÄ‚îÄ main_menu.png\n    ‚îú‚îÄ‚îÄ commands.png\n    ‚îú‚îÄ‚îÄ my_chats.png\n    ‚îî‚îÄ‚îÄ user_profile.png\n```\n\n## Current State\n- ‚úÖ Fresh GitHub import completed\n- ‚úÖ Security vulnerability in INSTALLATION.md resolved (removed hardcoded credentials)  \n- ‚úÖ Python environment and dependencies installed successfully\n- ‚úÖ Environment variable validation implemented with clear error messages\n- ‚úÖ Bot workflow configured and ready to run\n- ‚è≥ **Ready for user to provide credentials**: The bot is fully set up and will start once environment variables are configured\n\n## Dependencies\nThe bot requires the following Python packages:\n- aiogram==3.22.0 (Telegram Bot API library)\n- aiosqlite==0.21.0 (Async SQLite database)\n- Pillow==11.3.0 (Image processing)\n- matplotlib==3.10.6 (Graph generation)\n- requests==2.32.5 (HTTP requests)\n- aiofiles==24.1.0 (Async file operations)\n- openai==1.54.4 (OpenAI API for image generation)\n\n## Environment Variables Required\n- BOT_TOKEN: Telegram bot token\n- API_ID: Telegram API ID\n- API_HASH: Telegram API hash\n- OPENAI_API_KEY: OpenAI API key (optional, for image generation)\n\n## Architecture\n- **Backend only**: This is a console application that connects to Telegram API\n- **Database**: Uses SQLite for storing user data, ranks, warnings, and chat information\n- **No frontend**: The bot interface is entirely through Telegram\n- **Async**: Built on asyncio and aiogram for handling multiple users simultaneously\n\n## User Preferences\n- Security-focused: Uses environment variables for sensitive credentials\n- Following existing project structure and conventions\n- Maintaining Russian language support in bot messages","size_bytes":2932},"CustosBot/INSTALLATION.md":{"content":"# –£—Å—Ç–∞–Ω–æ–≤–∫–∞ Custos Telegram Bot –Ω–∞ Linux —Å–µ—Ä–≤–µ—Ä\n\n## –°–∏—Å—Ç–µ–º–Ω—ã–µ —Ç—Ä–µ–±–æ–≤–∞–Ω–∏—è\n\n- Linux —Å–µ—Ä–≤–µ—Ä (Ubuntu/CentOS/Debian)\n- Python 3.8 –∏–ª–∏ –≤—ã—à–µ\n- –î–æ—Å—Ç—É–ø –∫ –ø–∞–Ω–µ–ª–∏ —É–ø—Ä–∞–≤–ª–µ–Ω–∏—è (ispmanager)\n- –§–∞–π–ª–æ–≤—ã–π –º–µ–Ω–µ–¥–∂–µ—Ä\n\n## –ü–æ–¥–≥–æ—Ç–æ–≤–∫–∞ —Ñ–∞–π–ª–æ–≤\n\n### 1. –°—Ç—Ä—É–∫—Ç—É—Ä–∞ –ø—Ä–æ–µ–∫—Ç–∞ –¥–ª—è –∑–∞–≥—Ä—É–∑–∫–∏\n\n–£–±–µ–¥–∏—Ç–µ—Å—å, —á—Ç–æ —É –≤–∞—Å –µ—Å—Ç—å —Å–ª–µ–¥—É—é—â–∞—è —Å—Ç—Ä—É–∫—Ç—É—Ä–∞ —Ñ–∞–π–ª–æ–≤ –¥–ª—è –∑–∞–≥—Ä—É–∑–∫–∏:\n\n```\nCustosBot/\n‚îú‚îÄ‚îÄ main.py                 # –ì–ª–∞–≤–Ω—ã–π —Ñ–∞–π–ª –∑–∞–ø—É—Å–∫–∞\n‚îú‚îÄ‚îÄ config.py               # –ö–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏—è –±–æ—Ç–∞\n‚îú‚îÄ‚îÄ handlers/               # –û–±—Ä–∞–±–æ—Ç—á–∏–∫–∏ –∫–æ–º–∞–Ω–¥\n‚îÇ   ‚îú‚îÄ‚îÄ __init__.py\n‚îÇ   ‚îú‚îÄ‚îÄ main_handlers.py\n‚îÇ   ‚îú‚îÄ‚îÄ moderation_handlers.py\n‚îÇ   ‚îî‚îÄ‚îÄ user_handlers.py\n‚îú‚îÄ‚îÄ keyboards/              # –ö–ª–∞–≤–∏–∞—Ç—É—Ä—ã\n‚îÇ   ‚îî‚îÄ‚îÄ main_keyboards.py\n‚îú‚îÄ‚îÄ data/                   # –ë–∞–∑–∞ –¥–∞–Ω–Ω—ã—Ö\n‚îÇ   ‚îî‚îÄ‚îÄ database.py\n‚îú‚îÄ‚îÄ utils/                  # –£—Ç–∏–ª–∏—Ç—ã\n‚îÇ   ‚îú‚îÄ‚îÄ __init__.py\n‚îÇ   ‚îî‚îÄ‚îÄ image_generator.py\n‚îú‚îÄ‚îÄ images/                 # –ò–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è –±–æ—Ç–∞\n‚îÇ   ‚îú‚îÄ‚îÄ main_menu.png\n‚îÇ   ‚îú‚îÄ‚îÄ commands.png\n‚îÇ   ‚îú‚îÄ‚îÄ my_chats.png\n‚îÇ   ‚îú‚îÄ‚îÄ user_profile.png\n‚îÇ   ‚îî‚îÄ‚îÄ bot_avatar.png\n‚îî‚îÄ‚îÄ requirements.txt        # –ó–∞–≤–∏—Å–∏–º–æ—Å—Ç–∏\n```\n\n### 2. –°–æ–∑–¥–∞–Ω–∏–µ —Ñ–∞–π–ª–∞ requirements.txt\n\n–°–æ–∑–¥–∞–π—Ç–µ —Ñ–∞–π–ª `requirements.txt` –≤ –ø–∞–ø–∫–µ CustosBot —Å–æ —Å–ª–µ–¥—É—é—â–∏–º —Å–æ–¥–µ—Ä–∂–∏–º—ã–º:\n\n```\naiogram==3.22.0\naiosqlite==0.21.0\nPillow==11.3.0\nmatplotlib==3.10.6\nrequests==2.32.5\naiofiles==24.1.0\nopenai==1.54.4\n```\n\n## –£—Å—Ç–∞–Ω–æ–≤–∫–∞ —á–µ—Ä–µ–∑ ispmanager\n\n### –®–∞–≥ 1: –ó–∞–≥—Ä—É–∑–∫–∞ —Ñ–∞–π–ª–æ–≤\n\n1. –í–æ–π–¥–∏—Ç–µ –≤ ispmanager\n2. –ü–µ—Ä–µ–π–¥–∏—Ç–µ –≤ —Ä–∞–∑–¥–µ–ª \"–§–∞–π–ª–æ–≤—ã–π –º–µ–Ω–µ–¥–∂–µ—Ä\"\n3. –°–æ–∑–¥–∞–π—Ç–µ –ø–∞–ø–∫—É –¥–ª—è –±–æ—Ç–∞, –Ω–∞–ø—Ä–∏–º–µ—Ä: `/home/username/custos_bot/`\n4. –ó–∞–≥—Ä—É–∑–∏—Ç–µ –≤—Å—é –ø–∞–ø–∫—É `CustosBot` –≤ —Å–æ–∑–¥–∞–Ω–Ω—É—é –¥–∏—Ä–µ–∫—Ç–æ—Ä–∏—é\n\n### –®–∞–≥ 2: –ù–∞—Å—Ç—Ä–æ–π–∫–∞ –æ–∫—Ä—É–∂–µ–Ω–∏—è —á–µ—Ä–µ–∑ SSH\n\n–ü–æ–¥–∫–ª—é—á–∏—Ç–µ—Å—å –∫ —Å–µ—Ä–≤–µ—Ä—É —á–µ—Ä–µ–∑ SSH –∏ –≤—ã–ø–æ–ª–Ω–∏—Ç–µ —Å–ª–µ–¥—É—é—â–∏–µ –∫–æ–º–∞–Ω–¥—ã:\n\n```bash\n# –ü–µ—Ä–µ–π–¥–∏—Ç–µ –≤ –¥–∏—Ä–µ–∫—Ç–æ—Ä–∏—é —Å –±–æ—Ç–æ–º\ncd /home/username/custos_bot/CustosBot\n\n# –û–±–Ω–æ–≤–∏—Ç–µ —Å–∏—Å—Ç–µ–º—É\nsudo apt update\nsudo apt upgrade -y\n\n# –£—Å—Ç–∞–Ω–æ–≤–∏—Ç–µ Python –∏ pip (–µ—Å–ª–∏ –Ω–µ —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω—ã)\nsudo apt install python3 python3-pip python3-venv -y\n\n# –°–æ–∑–¥–∞–π—Ç–µ –≤–∏—Ä—Ç—É–∞–ª—å–Ω–æ–µ –æ–∫—Ä—É–∂–µ–Ω–∏–µ\npython3 -m venv venv\n\n# –ê–∫—Ç–∏–≤–∏—Ä—É–π—Ç–µ –≤–∏—Ä—Ç—É–∞–ª—å–Ω–æ–µ –æ–∫—Ä—É–∂–µ–Ω–∏–µ\nsource venv/bin/activate\n\n# –£—Å—Ç–∞–Ω–æ–≤–∏—Ç–µ –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç–∏\npip install -r requirements.txt\n\n# –°–æ–∑–¥–∞–π—Ç–µ –ø–∞–ø–∫—É –¥–ª—è –±–∞–∑—ã –¥–∞–Ω–Ω—ã—Ö\nmkdir -p data\n```\n\n### –®–∞–≥ 3: –ù–∞—Å—Ç—Ä–æ–π–∫–∞ API –∫–ª—é—á–µ–π\n\n–ï—Å–ª–∏ –≤—ã –ø–ª–∞–Ω–∏—Ä—É–µ—Ç–µ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å –≥–µ–Ω–µ—Ä–∞—Ü–∏—é –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–π —á–µ—Ä–µ–∑ OpenAI:\n\n```bash\n# –≠–∫—Å–ø–æ—Ä—Ç–∏—Ä—É–π—Ç–µ API –∫–ª—é—á–∏ (–∑–∞–º–µ–Ω–∏—Ç–µ –Ω–∞ –≤–∞—à–∏ –∫–ª—é—á–∏)\nexport OPENAI_API_KEY=\"your-openai-api-key-here\"\n\n# –î–ª—è –ø–æ—Å—Ç–æ—è–Ω–Ω–æ–≥–æ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏—è –¥–æ–±–∞–≤—å—Ç–µ –≤ .bashrc\necho 'export OPENAI_API_KEY=\"your-openai-api-key-here\"' >> ~/.bashrc\n```\n\n### –®–∞–≥ 4: –ü—Ä–æ–≤–µ—Ä–∫–∞ –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏–∏\n\n–£–±–µ–¥–∏—Ç–µ—Å—å, —á—Ç–æ –≤ —Ñ–∞–π–ª–µ `config.py` –∏—Å–ø–æ–ª—å–∑—É—é—Ç—Å—è –ø–µ—Ä–µ–º–µ–Ω–Ω—ã–µ –æ–∫—Ä—É–∂–µ–Ω–∏—è –¥–ª—è –±–µ–∑–æ–ø–∞—Å–Ω–æ—Å—Ç–∏:\n\n```python\nBOT_TOKEN = os.environ.get(\"BOT_TOKEN\")\nAPI_ID = int(os.environ.get(\"API_ID\", \"0\"))\nAPI_HASH = os.environ.get(\"API_HASH\")\n```\n\n–£—Å—Ç–∞–Ω–æ–≤–∏—Ç–µ –ø–µ—Ä–µ–º–µ–Ω–Ω—ã–µ –æ–∫—Ä—É–∂–µ–Ω–∏—è —Å –≤–∞—à–∏–º–∏ —Ä–µ–∞–ª—å–Ω—ã–º–∏ –∑–Ω–∞—á–µ–Ω–∏—è–º–∏:\n\n```bash\nexport BOT_TOKEN=\"your-bot-token-here\"\nexport API_ID=\"your-api-id-here\"\nexport API_HASH=\"your-api-hash-here\"\n```\n\n### –®–∞–≥ 5: –¢–µ—Å—Ç–æ–≤—ã–π –∑–∞–ø—É—Å–∫\n\n```bash\n# –ê–∫—Ç–∏–≤–∏—Ä—É–π—Ç–µ –≤–∏—Ä—Ç—É–∞–ª—å–Ω–æ–µ –æ–∫—Ä—É–∂–µ–Ω–∏–µ (–µ—Å–ª–∏ –Ω–µ –∞–∫—Ç–∏–≤–∏—Ä–æ–≤–∞–Ω–æ)\nsource venv/bin/activate\n\n# –ó–∞–ø—É—Å—Ç–∏—Ç–µ –±–æ—Ç–∞ –¥–ª—è —Ç–µ—Å—Ç–∏—Ä–æ–≤–∞–Ω–∏—è\npython main.py\n```\n\n–ï—Å–ª–∏ –±–æ—Ç –∑–∞–ø—É—Å—Ç–∏–ª—Å—è –±–µ–∑ –æ—à–∏–±–æ–∫, –≤—ã —É–≤–∏–¥–∏—Ç–µ —Å–æ–æ–±—â–µ–Ω–∏–µ:\n```\nINFO:__main__:Custos Bot is starting...\nINFO:aiogram.dispatcher:Start polling\nINFO:aiogram.dispatcher:Run polling for bot @custoschatbot id=8356598661 - 'Custos | –ß–∞—Ç-–º–µ–Ω–µ–¥–∂–µ—Ä'\n```\n\n## –ê–≤—Ç–æ–∑–∞–ø—É—Å–∫ –±–æ—Ç–∞\n\n### –°–æ–∑–¥–∞–Ω–∏–µ systemd —Å–µ—Ä–≤–∏—Å–∞\n\n1. –°–æ–∑–¥–∞–π—Ç–µ —Ñ–∞–π–ª —Å–µ—Ä–≤–∏—Å–∞:\n\n```bash\nsudo nano /etc/systemd/system/custos-bot.service\n```\n\n2. –î–æ–±–∞–≤—å—Ç–µ —Å–ª–µ–¥—É—é—â–∏–π —Å–æ–¥–µ—Ä–∂–∏–º–æ–µ:\n\n```ini\n[Unit]\nDescription=Custos Telegram Bot\nAfter=network.target\n\n[Service]\nType=simple\nUser=username\nWorkingDirectory=/home/username/custos_bot/CustosBot\nEnvironment=PATH=/home/username/custos_bot/CustosBot/venv/bin\nEnvironment=BOT_TOKEN=your-bot-token-here\nEnvironment=API_ID=your-api-id-here\nEnvironment=API_HASH=your-api-hash-here\nEnvironment=OPENAI_API_KEY=your-openai-api-key-here\nExecStart=/home/username/custos_bot/CustosBot/venv/bin/python main.py\nRestart=always\nRestartSec=3\n\n[Install]\nWantedBy=multi-user.target\n```\n\n3. –ó–∞–º–µ–Ω–∏—Ç–µ `username` –Ω–∞ –≤–∞—à–µ –∏–º—è –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è –∏ `your-openai-api-key-here` –Ω–∞ –≤–∞—à API –∫–ª—é—á.\n\n4. –ê–∫—Ç–∏–≤–∏—Ä—É–π—Ç–µ —Å–µ—Ä–≤–∏—Å:\n\n```bash\n# –ü–µ—Ä–µ–∑–∞–≥—Ä—É–∑–∏—Ç–µ systemd\nsudo systemctl daemon-reload\n\n# –í–∫–ª—é—á–∏—Ç–µ –∞–≤—Ç–æ–∑–∞–ø—É—Å–∫\nsudo systemctl enable custos-bot.service\n\n# –ó–∞–ø—É—Å—Ç–∏—Ç–µ —Å–µ—Ä–≤–∏—Å\nsudo systemctl start custos-bot.service\n\n# –ü—Ä–æ–≤–µ—Ä—å—Ç–µ —Å—Ç–∞—Ç—É—Å\nsudo systemctl status custos-bot.service\n```\n\n## –£–ø—Ä–∞–≤–ª–µ–Ω–∏–µ –±–æ—Ç–æ–º\n\n### –û—Å–Ω–æ–≤–Ω—ã–µ –∫–æ–º–∞–Ω–¥—ã\n\n```bash\n# –ó–∞–ø—É—Å–∫ –±–æ—Ç–∞\nsudo systemctl start custos-bot.service\n\n# –û—Å—Ç–∞–Ω–æ–≤–∫–∞ –±–æ—Ç–∞\nsudo systemctl stop custos-bot.service\n\n# –ü–µ—Ä–µ–∑–∞–ø—É—Å–∫ –±–æ—Ç–∞\nsudo systemctl restart custos-bot.service\n\n# –ü—Ä–æ—Å–º–æ—Ç—Ä –ª–æ–≥–æ–≤\nsudo journalctl -u custos-bot.service -f\n\n# –ü—Ä–æ–≤–µ—Ä–∫–∞ —Å—Ç–∞—Ç—É—Å–∞\nsudo systemctl status custos-bot.service\n```\n\n### –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ –±–æ—Ç–∞\n\n1. –û—Å—Ç–∞–Ω–æ–≤–∏—Ç–µ —Å–µ—Ä–≤–∏—Å:\n```bash\nsudo systemctl stop custos-bot.service\n```\n\n2. –ó–∞–≥—Ä—É–∑–∏—Ç–µ –Ω–æ–≤—ã–µ —Ñ–∞–π–ª—ã —á–µ—Ä–µ–∑ ispmanager —Ñ–∞–π–ª–æ–≤—ã–π –º–µ–Ω–µ–¥–∂–µ—Ä\n\n3. –ü–µ—Ä–µ–∑–∞–ø—É—Å—Ç–∏—Ç–µ —Å–µ—Ä–≤–∏—Å:\n```bash\nsudo systemctl start custos-bot.service\n```\n\n## –ú–æ–Ω–∏—Ç–æ—Ä–∏–Ω–≥ –∏ –ª–æ–≥–∏\n\n### –ü—Ä–æ—Å–º–æ—Ç—Ä –ª–æ–≥–æ–≤ –±–æ—Ç–∞\n```bash\n# –¢–µ–∫—É—â–∏–µ –ª–æ–≥–∏\nsudo journalctl -u custos-bot.service\n\n# –õ–æ–≥–∏ –≤ —Ä–µ–∞–ª—å–Ω–æ–º –≤—Ä–µ–º–µ–Ω–∏\nsudo journalctl -u custos-bot.service -f\n\n# –ü–æ—Å–ª–µ–¥–Ω–∏–µ 100 —Å—Ç—Ä–æ–∫ –ª–æ–≥–æ–≤\nsudo journalctl -u custos-bot.service -n 100\n```\n\n### –†–µ–∑–µ—Ä–≤–Ω–æ–µ –∫–æ–ø–∏—Ä–æ–≤–∞–Ω–∏–µ –±–∞–∑—ã –¥–∞–Ω–Ω—ã—Ö\n```bash\n# –°–æ–∑–¥–∞–Ω–∏–µ —Ä–µ–∑–µ—Ä–≤–Ω–æ–π –∫–æ–ø–∏–∏\ncp /home/username/custos_bot/CustosBot/data/custos.db /home/username/backup/custos_$(date +%Y%m%d_%H%M%S).db\n```\n\n## –£—Å—Ç—Ä–∞–Ω–µ–Ω–∏–µ –ø—Ä–æ–±–ª–µ–º\n\n### –ß–∞—Å—Ç—ã–µ –æ—à–∏–±–∫–∏\n\n1. **–ë–æ—Ç –Ω–µ –æ—Ç–≤–µ—á–∞–µ—Ç**\n   - –ü—Ä–æ–≤–µ—Ä—å—Ç–µ —Ç–æ–∫–µ–Ω –±–æ—Ç–∞ –≤ config.py\n   - –£–±–µ–¥–∏—Ç–µ—Å—å, —á—Ç–æ –±–æ—Ç –∑–∞–ø—É—â–µ–Ω: `sudo systemctl status custos-bot.service`\n\n2. **–û—à–∏–±–∫–∏ –º–æ–¥—É–ª–µ–π Python**\n   - –ü–µ—Ä–µ—É—Å—Ç–∞–Ω–æ–≤–∏—Ç–µ –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç–∏: `pip install -r requirements.txt`\n\n3. **–û—à–∏–±–∫–∏ –±–∞–∑—ã –¥–∞–Ω–Ω—ã—Ö**\n   - –ü—Ä–æ–≤–µ—Ä—å—Ç–µ –ø—Ä–∞–≤–∞ –¥–æ—Å—Ç—É–ø–∞ –∫ –ø–∞–ø–∫–µ data\n   - –£–±–µ–¥–∏—Ç–µ—Å—å, —á—Ç–æ –±–∞–∑–∞ –¥–∞–Ω–Ω—ã—Ö —Å–æ–∑–¥–∞–ª–∞—Å—å: `ls -la data/`\n\n4. **–û—à–∏–±–∫–∏ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–π**\n   - –ü—Ä–æ–≤–µ—Ä—å—Ç–µ –Ω–∞–ª–∏—á–∏–µ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–π –≤ –ø–∞–ø–∫–µ images/\n   - –£–±–µ–¥–∏—Ç–µ—Å—å –≤ –ø—Ä–∞–≤–∏–ª—å–Ω–æ—Å—Ç–∏ OPENAI_API_KEY (–µ—Å–ª–∏ –∏—Å–ø–æ–ª—å–∑—É–µ—Ç—Å—è)\n\n### –ü–µ—Ä–µ–∑–∞–ø—É—Å–∫ –±–æ—Ç–∞ –ø—Ä–∏ –æ—à–∏–±–∫–∞—Ö\n```bash\n# –ü–æ–ª–Ω–∞—è –ø–µ—Ä–µ–∑–∞–≥—Ä—É–∑–∫–∞\nsudo systemctl stop custos-bot.service\nsleep 5\nsudo systemctl start custos-bot.service\n```\n\n## –ö–æ–Ω—Ç–∞–∫—Ç—ã –∏ –ø–æ–¥–¥–µ—Ä–∂–∫–∞\n\n–ï—Å–ª–∏ —É –≤–∞—Å –≤–æ–∑–Ω–∏–∫–ª–∏ –ø—Ä–æ–±–ª–µ–º—ã —Å —É—Å—Ç–∞–Ω–æ–≤–∫–æ–π –∏–ª–∏ –Ω–∞—Å—Ç—Ä–æ–π–∫–æ–π –±–æ—Ç–∞, –ø—Ä–æ–≤–µ—Ä—å—Ç–µ:\n\n1. –õ–æ–≥–∏ —Å–µ—Ä–≤–∏—Å–∞: `sudo journalctl -u custos-bot.service -f`\n2. –ü—Ä–∞–≤–∞ –¥–æ—Å—Ç—É–ø–∞ –∫ —Ñ–∞–π–ª–∞–º\n3. –ö–æ—Ä—Ä–µ–∫—Ç–Ω–æ—Å—Ç—å —Ç–æ–∫–µ–Ω–æ–≤ –≤ config.py\n4. –î–æ—Å—Ç—É–ø–Ω–æ—Å—Ç—å –∏–Ω—Ç–µ—Ä–Ω–µ—Ç-—Å–æ–µ–¥–∏–Ω–µ–Ω–∏—è\n\n–ë–æ—Ç –≥–æ—Ç–æ–≤ –∫ —Ä–∞–±–æ—Ç–µ! –î–æ–±–∞–≤—å—Ç–µ –µ–≥–æ –≤ –≤–∞—à–∏ —á–∞—Ç—ã –∏ –Ω–∞—á–Ω–∏—Ç–µ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å –∫–æ–º–∞–Ω–¥—ã —É–ø—Ä–∞–≤–ª–µ–Ω–∏—è.","size_bytes":8792},"CustosBot/config.py":{"content":"# Bot configuration\nimport os\n\nBOT_TOKEN = os.environ.get(\"BOT_TOKEN\")\nAPI_ID = int(os.environ.get(\"API_ID\", \"0\"))\nAPI_HASH = os.environ.get(\"API_HASH\")\n\n# Validate required environment variables\nif not BOT_TOKEN:\n    print(\"ERROR: BOT_TOKEN environment variable is required!\")\n    print(\"Please set it using: export BOT_TOKEN='your-bot-token-here'\")\n\nif API_ID == 0:\n    print(\"WARNING: API_ID environment variable is not set or invalid!\")\n    print(\"Please set it using: export API_ID='your-api-id-here'\")\n\nif not API_HASH:\n    print(\"WARNING: API_HASH environment variable is not set!\")\n    print(\"Please set it using: export API_HASH='your-api-hash-here'\")\n\n# Bot commands help text\nBOT_DESCRIPTION = \"\"\"\nü§ñ **Custos | –ß–∞—Ç-–º–µ–Ω–µ–¥–∂–µ—Ä** ‚Äî –≤–∞—à –ø–æ–º–æ—â–Ω–∏–∫ –¥–ª—è —É–ø—Ä–∞–≤–ª–µ–Ω–∏—è —á–∞—Ç–∞–º–∏\n\n**–û—Å–Ω–æ–≤–Ω—ã–µ —Ñ—É–Ω–∫—Ü–∏–∏:**\n‚Ä¢ –°–∏—Å—Ç–µ–º–∞ —Ä–∞–Ω–≥–æ–≤ (—É—á–∞—Å—Ç–Ω–∏–∫ ‚Üí –º–æ–¥–µ—Ä–∞—Ç–æ—Ä ‚Üí –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä ‚Üí –≤–ª–∞–¥–µ–ª–µ—Ü)\n‚Ä¢ –ú–æ–¥–µ—Ä–∞—Ü–∏—è —á–∞—Ç–∞ (–±–∞–Ω—ã, –≤–∞—Ä–Ω—ã, –∫–∏–∫–∏)\n‚Ä¢ –ü–µ—Ä—Å–æ–Ω–∞–ª—å–Ω—ã–µ –ø—Ä–æ—Ñ–∏–ª–∏ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π\n‚Ä¢ –°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞ –∞–∫—Ç–∏–≤–Ω–æ—Å—Ç–∏ —á–∞—Ç–∞\n\n**–ö–æ–º–∞–Ω–¥—ã –¥–æ—Å—Ç—É–ø–Ω—ã —Ç–æ–ª—å–∫–æ –≤ –≥—Ä—É–ø–ø–æ–≤—ã—Ö —á–∞—Ç–∞—Ö!**\n\"\"\"\n\n# Rank system\nRANKS = {\n    'participant': 0,\n    'moderator': 1,\n    'administrator': 2,\n    'owner': 3\n}\n\nRANK_NAMES = {\n    'participant': '–£—á–∞—Å—Ç–Ω–∏–∫',\n    'moderator': '–ú–æ–¥–µ—Ä–∞—Ç–æ—Ä', \n    'administrator': '–ê–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä',\n    'owner': '–í–ª–∞–¥–µ–ª–µ—Ü'\n}\n\n# Command permissions\nCOMMAND_PERMISSIONS = {\n    'upstaff': ['administrator', 'owner'],\n    'ban': ['administrator', 'owner'],\n    'warn': ['moderator', 'administrator', 'owner'],\n    'kick': ['moderator', 'administrator', 'owner']\n}\n\n# Rate limits (in seconds)\nRATE_LIMITS = {\n    'warn_moderator': 3600,  # 1 hour for moderators\n    'kick_moderator': 900    # 15 minutes for moderators\n}","size_bytes":1942},"CustosBot/main.py":{"content":"import asyncio\nimport logging\nimport os\nfrom aiogram import Bot, Dispatcher\nfrom aiogram.client.default import DefaultBotProperties\nfrom aiogram.enums import ParseMode\n\nfrom handlers import main_handlers, moderation_handlers, user_handlers\nfrom data.database import Database\nfrom config import BOT_TOKEN\n\n# Set up logging\nlogging.basicConfig(level=logging.INFO)\nlogger = logging.getLogger(__name__)\n\nasync def main():\n    \"\"\"Main function to start the bot\"\"\"\n    # Check if BOT_TOKEN is available\n    if not BOT_TOKEN:\n        logger.error(\"BOT_TOKEN is not set! Please configure environment variables.\")\n        logger.error(\"Required environment variables:\")\n        logger.error(\"- BOT_TOKEN: Your Telegram bot token\")\n        logger.error(\"- API_ID: Your Telegram API ID\")\n        logger.error(\"- API_HASH: Your Telegram API hash\")\n        logger.error(\"- OPENAI_API_KEY: Your OpenAI API key (optional)\")\n        return\n    \n    # Initialize bot and dispatcher\n    bot = Bot(\n        token=BOT_TOKEN,\n        default=DefaultBotProperties(parse_mode=ParseMode.HTML)\n    )\n    dp = Dispatcher()\n    \n    # Initialize database\n    db = Database()\n    await db.init_db()\n    \n    # Register routers\n    dp.include_router(main_handlers.router)\n    dp.include_router(moderation_handlers.router)\n    dp.include_router(user_handlers.router)\n    \n    # Create images directory\n    os.makedirs(\"CustosBot/images\", exist_ok=True)\n    \n    logger.info(\"Custos Bot is starting...\")\n    \n    # Start polling\n    try:\n        await dp.start_polling(bot)\n    except Exception as e:\n        logger.error(f\"Bot error: {e}\")\n    finally:\n        await bot.session.close()\n\nif __name__ == \"__main__\":\n    asyncio.run(main())","size_bytes":1708},"CustosBot/data/database.py":{"content":"import aiosqlite\nimport asyncio\nfrom datetime import datetime\nfrom typing import Optional, List, Dict\n\nclass Database:\n    def __init__(self, db_path: str = \"data/custos.db\"):\n        self.db_path = db_path\n    \n    async def init_db(self):\n        \"\"\"Initialize database with required tables\"\"\"\n        async with aiosqlite.connect(self.db_path) as db:\n            # Users table\n            await db.execute(\"\"\"\n                CREATE TABLE IF NOT EXISTS users (\n                    user_id INTEGER PRIMARY KEY,\n                    username TEXT,\n                    first_name TEXT,\n                    last_name TEXT,\n                    nickname TEXT,\n                    description TEXT,\n                    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP\n                )\n            \"\"\")\n            \n            # Chat members table with ranks\n            await db.execute(\"\"\"\n                CREATE TABLE IF NOT EXISTS chat_members (\n                    id INTEGER PRIMARY KEY AUTOINCREMENT,\n                    user_id INTEGER,\n                    chat_id INTEGER,\n                    rank TEXT DEFAULT 'participant',\n                    message_count INTEGER DEFAULT 0,\n                    joined_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,\n                    UNIQUE(user_id, chat_id)\n                )\n            \"\"\")\n            \n            # Warnings table\n            await db.execute(\"\"\"\n                CREATE TABLE IF NOT EXISTS warnings (\n                    id INTEGER PRIMARY KEY AUTOINCREMENT,\n                    user_id INTEGER,\n                    chat_id INTEGER,\n                    reason TEXT,\n                    issued_by INTEGER,\n                    issued_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP\n                )\n            \"\"\")\n            \n            # Chats table\n            await db.execute(\"\"\"\n                CREATE TABLE IF NOT EXISTS chats (\n                    chat_id INTEGER PRIMARY KEY,\n                    title TEXT,\n                    type TEXT,\n                    added_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP\n                )\n            \"\"\")\n            \n            # Message statistics\n            await db.execute(\"\"\"\n                CREATE TABLE IF NOT EXISTS message_stats (\n                    id INTEGER PRIMARY KEY AUTOINCREMENT,\n                    user_id INTEGER,\n                    chat_id INTEGER,\n                    date TEXT,\n                    count INTEGER DEFAULT 1,\n                    UNIQUE(user_id, chat_id, date)\n                )\n            \"\"\")\n            \n            await db.commit()\n    \n    async def add_user(self, user_id: int, username: Optional[str] = None, first_name: Optional[str] = None, last_name: Optional[str] = None):\n        \"\"\"Add or update user in database\"\"\"\n        async with aiosqlite.connect(self.db_path) as db:\n            await db.execute(\"\"\"\n                INSERT OR REPLACE INTO users (user_id, username, first_name, last_name)\n                VALUES (?, ?, ?, ?)\n            \"\"\", (user_id, username, first_name, last_name))\n            await db.commit()\n    \n    async def add_chat_member(self, user_id: int, chat_id: int, rank: str = 'participant'):\n        \"\"\"Add user to chat with specified rank\"\"\"\n        async with aiosqlite.connect(self.db_path) as db:\n            await db.execute(\"\"\"\n                INSERT OR IGNORE INTO chat_members (user_id, chat_id, rank)\n                VALUES (?, ?, ?)\n            \"\"\", (user_id, chat_id, rank))\n            await db.commit()\n    \n    async def update_user_rank(self, user_id: int, chat_id: int, new_rank: str):\n        \"\"\"Update user rank in specific chat\"\"\"\n        async with aiosqlite.connect(self.db_path) as db:\n            await db.execute(\"\"\"\n                UPDATE chat_members SET rank = ? WHERE user_id = ? AND chat_id = ?\n            \"\"\", (new_rank, user_id, chat_id))\n            await db.commit()\n    \n    async def get_user_rank(self, user_id: int, chat_id: int) -> Optional[str]:\n        \"\"\"Get user rank in specific chat\"\"\"\n        async with aiosqlite.connect(self.db_path) as db:\n            cursor = await db.execute(\"\"\"\n                SELECT rank FROM chat_members WHERE user_id = ? AND chat_id = ?\n            \"\"\", (user_id, chat_id))\n            result = await cursor.fetchone()\n            return result[0] if result else None\n    \n    async def add_warning(self, user_id: int, chat_id: int, reason: str, issued_by: int):\n        \"\"\"Add warning to user\"\"\"\n        async with aiosqlite.connect(self.db_path) as db:\n            await db.execute(\"\"\"\n                INSERT INTO warnings (user_id, chat_id, reason, issued_by)\n                VALUES (?, ?, ?, ?)\n            \"\"\", (user_id, chat_id, reason, issued_by))\n            await db.commit()\n    \n    async def get_warning_count(self, user_id: int, chat_id: int) -> int:\n        \"\"\"Get warning count for user in chat\"\"\"\n        async with aiosqlite.connect(self.db_path) as db:\n            cursor = await db.execute(\"\"\"\n                SELECT COUNT(*) FROM warnings WHERE user_id = ? AND chat_id = ?\n            \"\"\", (user_id, chat_id))\n            result = await cursor.fetchone()\n            return result[0] if result else 0\n    \n    async def set_user_nickname(self, user_id: int, nickname: str):\n        \"\"\"Set user nickname\"\"\"\n        async with aiosqlite.connect(self.db_path) as db:\n            await db.execute(\"\"\"\n                UPDATE users SET nickname = ? WHERE user_id = ?\n            \"\"\", (nickname, user_id))\n            await db.commit()\n    \n    async def set_user_description(self, user_id: int, description: str):\n        \"\"\"Set user description\"\"\"\n        async with aiosqlite.connect(self.db_path) as db:\n            await db.execute(\"\"\"\n                UPDATE users SET description = ? WHERE user_id = ?\n            \"\"\", (description, user_id))\n            await db.commit()\n    \n    async def get_user_info(self, user_id: int) -> Optional[Dict]:\n        \"\"\"Get user information\"\"\"\n        async with aiosqlite.connect(self.db_path) as db:\n            cursor = await db.execute(\"\"\"\n                SELECT username, first_name, last_name, nickname, description \n                FROM users WHERE user_id = ?\n            \"\"\", (user_id,))\n            result = await cursor.fetchone()\n            if result:\n                return {\n                    'username': result[0],\n                    'first_name': result[1],\n                    'last_name': result[2],\n                    'nickname': result[3],\n                    'description': result[4]\n                }\n            return None\n    \n    async def get_staff_list(self, chat_id: int) -> Dict[str, List]:\n        \"\"\"Get staff list organized by rank\"\"\"\n        async with aiosqlite.connect(self.db_path) as db:\n            cursor = await db.execute(\"\"\"\n                SELECT u.user_id, u.username, u.first_name, u.nickname, cm.rank\n                FROM users u\n                JOIN chat_members cm ON u.user_id = cm.user_id\n                WHERE cm.chat_id = ? AND cm.rank != 'participant'\n                ORDER BY \n                    CASE cm.rank \n                        WHEN 'owner' THEN 1\n                        WHEN 'administrator' THEN 2\n                        WHEN 'moderator' THEN 3\n                        ELSE 4\n                    END\n            \"\"\", (chat_id,))\n            results = await cursor.fetchall()\n            \n            staff = {'owner': [], 'administrator': [], 'moderator': []}\n            for row in results:\n                user_info = {\n                    'user_id': row[0],\n                    'username': row[1],\n                    'first_name': row[2],\n                    'nickname': row[3]\n                }\n                rank = row[4]\n                if rank in staff:\n                    staff[rank].append(user_info)\n            \n            return staff\n    \n    async def add_chat(self, chat_id: int, title: str, chat_type: str):\n        \"\"\"Add chat to database\"\"\"\n        async with aiosqlite.connect(self.db_path) as db:\n            await db.execute(\"\"\"\n                INSERT OR REPLACE INTO chats (chat_id, title, type)\n                VALUES (?, ?, ?)\n            \"\"\", (chat_id, title, chat_type))\n            await db.commit()\n    \n    async def get_user_chats(self, user_id: int) -> List[Dict]:\n        \"\"\"Get list of chats where user is a member\"\"\"\n        async with aiosqlite.connect(self.db_path) as db:\n            cursor = await db.execute(\"\"\"\n                SELECT c.chat_id, c.title, c.type, cm.rank\n                FROM chats c\n                JOIN chat_members cm ON c.chat_id = cm.chat_id\n                WHERE cm.user_id = ?\n            \"\"\", (user_id,))\n            results = await cursor.fetchall()\n            \n            chats = []\n            for row in results:\n                chats.append({\n                    'chat_id': row[0],\n                    'title': row[1],\n                    'type': row[2],\n                    'rank': row[3]\n                })\n            \n            return chats\n    \n    async def increment_message_count(self, user_id: int, chat_id: int):\n        \"\"\"Increment user message count for today\"\"\"\n        today = datetime.now().strftime('%Y-%m-%d')\n        async with aiosqlite.connect(self.db_path) as db:\n            await db.execute(\"\"\"\n                INSERT OR IGNORE INTO message_stats (user_id, chat_id, date, count)\n                VALUES (?, ?, ?, 1)\n            \"\"\", (user_id, chat_id, today))\n            \n            await db.execute(\"\"\"\n                UPDATE message_stats SET count = count + 1 \n                WHERE user_id = ? AND chat_id = ? AND date = ?\n            \"\"\", (user_id, chat_id, today))\n            \n            await db.execute(\"\"\"\n                UPDATE chat_members SET message_count = message_count + 1\n                WHERE user_id = ? AND chat_id = ?\n            \"\"\", (user_id, chat_id))\n            \n            await db.commit()\n    \n    async def get_user_message_count(self, user_id: int, chat_id: int) -> int:\n        \"\"\"Get total message count for user in chat\"\"\"\n        async with aiosqlite.connect(self.db_path) as db:\n            cursor = await db.execute(\"\"\"\n                SELECT message_count FROM chat_members \n                WHERE user_id = ? AND chat_id = ?\n            \"\"\", (user_id, chat_id))\n            result = await cursor.fetchone()\n            return result[0] if result else 0","size_bytes":10371},"CustosBot/handlers/__init__.py":{"content":"# Handlers package","size_bytes":18},"CustosBot/handlers/main_handlers.py":{"content":"from aiogram import F, Router\nfrom aiogram.types import Message, CallbackQuery, FSInputFile\nfrom aiogram.filters import Command, CommandStart\nimport sys\nimport os\nsys.path.append(os.path.dirname(os.path.dirname(os.path.abspath(__file__))))\n\nfrom keyboards.main_keyboards import get_main_menu_keyboard, get_menu_buttons_keyboard\nfrom data.database import Database\nfrom utils.image_generator import image_gen\nfrom config import BOT_DESCRIPTION\n\nrouter = Router()\ndb = Database()\n\n@router.message(CommandStart())\nasync def start_command(message: Message):\n    \"\"\"Handle /start command\"\"\"\n    user = message.from_user\n    if not user:\n        return\n    \n    # Add user to database\n    await db.add_user(user.id, user.username, user.first_name, user.last_name)\n    \n    # Check if it's a private chat\n    if message.chat.type == 'private':\n        # Generate main menu image if not exists\n        image_path = \"CustosBot/images/main_menu.png\"\n        if not os.path.exists(image_path):\n            try:\n                await image_gen.generate_main_menu_image()\n            except Exception as e:\n                print(f\"Failed to generate main menu image: {e}\")\n        \n        # Send main menu with image\n        try:\n            if os.path.exists(image_path):\n                photo = FSInputFile(image_path)\n                await message.answer_photo(\n                    photo=photo,\n                    caption=BOT_DESCRIPTION,\n                    reply_markup=get_main_menu_keyboard()\n                )\n            else:\n                await message.answer(\n                    BOT_DESCRIPTION,\n                    reply_markup=get_main_menu_keyboard()\n                )\n        except Exception as e:\n            await message.answer(\n                BOT_DESCRIPTION,\n                reply_markup=get_main_menu_keyboard()\n            )\n        \n        # Send menu buttons\n        await message.answer(\n            \"–í—ã–±–µ—Ä–∏—Ç–µ –¥–µ–π—Å—Ç–≤–∏–µ:\",\n            reply_markup=get_menu_buttons_keyboard()\n        )\n    else:\n        # In group chat - add chat and user as member\n        chat = message.chat\n        await db.add_chat(chat.id, chat.title or \"Unknown Chat\", chat.type)\n        await db.add_chat_member(user.id, chat.id)\n        \n        await message.answer(\n            \"üëã –ü—Ä–∏–≤–µ—Ç! –Ø Custos - –≤–∞—à —á–∞—Ç-–º–µ–Ω–µ–¥–∂–µ—Ä. –ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ –∫–æ–º–∞–Ω–¥—ã –¥–ª—è —É–ø—Ä–∞–≤–ª–µ–Ω–∏—è —á–∞—Ç–æ–º!\"\n        )\n\n@router.message(Command(\"help\"))\nasync def help_command(message: Message):\n    \"\"\"Handle /help command\"\"\"\n    # Generate commands image if not exists\n    image_path = \"CustosBot/images/commands.png\"\n    if not os.path.exists(image_path):\n        try:\n            await image_gen.generate_commands_image()\n        except Exception as e:\n            print(f\"Failed to generate commands image: {e}\")\n    \n    help_text = \"\"\"\nüìã **–ö–æ–º–∞–Ω–¥—ã –±–æ—Ç–∞**\n\n**–ú–æ–¥–µ—Ä–∞—Ü–∏—è (—Ç–æ–ª—å–∫–æ –≤ —á–∞—Ç–∞—Ö):**\n‚Ä¢ `/upstaff [—á–∏—Å–ª–æ] [–ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å]` - –ø–æ–≤—ã—Å–∏—Ç—å —Ä–∞–Ω–≥\n‚Ä¢ `/ban [–ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å] [–ø—Ä–∏—á–∏–Ω–∞]` - –∑–∞–±–∞–Ω–∏—Ç—å\n‚Ä¢ `/warn [–ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å] [–ø—Ä–∏—á–∏–Ω–∞]` - –≤—ã–¥–∞—Ç—å –≤–∞—Ä–Ω\n‚Ä¢ `/kick [–ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å] [–ø—Ä–∏—á–∏–Ω–∞]` - –∫–∏–∫–Ω—É—Ç—å\n‚Ä¢ `/staff` - —Å–ø–∏—Å–æ–∫ –ø–µ—Ä—Å–æ–Ω–∞–ª–∞\n\n**–ü—Ä–æ—Ñ–∏–ª—å:**\n‚Ä¢ `/me` –∏–ª–∏ `–∫—Ç–æ —è` - –º–æ—è –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—è\n‚Ä¢ `/you [–ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å]` –∏–ª–∏ `–∫—Ç–æ —Ç—ã` - –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—è –æ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ\n‚Ä¢ `/nickname +–∏–º—è` - —É—Å—Ç–∞–Ω–æ–≤–∏—Ç—å –Ω–∏–∫–Ω–µ–π–º\n‚Ä¢ `/description +–æ–ø–∏—Å–∞–Ω–∏–µ` - —É—Å—Ç–∞–Ω–æ–≤–∏—Ç—å –æ–ø–∏—Å–∞–Ω–∏–µ\n\n–ü–æ–ª–Ω—ã–π —Å–ø–∏—Å–æ–∫ –∫–æ–º–∞–Ω–¥ –≤ –Ω–∞—à–µ–π [—Å—Ç–∞—Ç—å–µ](https://teletype.in/@unisonqq/custoscommands)\n\"\"\"\n    \n    try:\n        if os.path.exists(image_path):\n            photo = FSInputFile(image_path)\n            await message.answer_photo(\n                photo=photo,\n                caption=help_text,\n                parse_mode=\"Markdown\"\n            )\n        else:\n            await message.answer(help_text, parse_mode=\"Markdown\")\n    except Exception as e:\n        await message.answer(help_text, parse_mode=\"Markdown\")\n\n@router.message(F.text == \"üí¨ –ú–æ–∏ —á–∞—Ç—ã\")\nasync def my_chats_command(message: Message):\n    \"\"\"Handle 'My Chats' button\"\"\"\n    user = message.from_user\n    if not user:\n        return\n    \n    # Only work in private chat\n    if message.chat.type != 'private':\n        return\n    \n    # Generate my chats image if not exists\n    image_path = \"CustosBot/images/my_chats.png\"\n    if not os.path.exists(image_path):\n        try:\n            await image_gen.generate_my_chats_image()\n        except Exception as e:\n            print(f\"Failed to generate my chats image: {e}\")\n    \n    # Get user's chats\n    chats = await db.get_user_chats(user.id)\n    \n    if not chats:\n        await message.answer(\"üì≠ –í—ã –Ω–µ —Å–æ—Å—Ç–æ–∏—Ç–µ –Ω–∏ –≤ –æ–¥–Ω–æ–º —á–∞—Ç–µ —Å –±–æ—Ç–æ–º.\")\n        return\n    \n    # Build chat list\n    chat_text = \"üí¨ **–ú–æ–∏ —á–∞—Ç—ã:**\\n\\n\"\n    for chat in chats:\n        chat_id = chat['chat_id']\n        title = chat['title']\n        rank = chat['rank']\n        \n        # Create chat link (negative ID for groups)\n        if chat_id < 0:\n            chat_link = f\"https://t.me/c/{str(chat_id)[4:]}/1\"  # Remove -100 prefix\n        else:\n            chat_link = f\"https://t.me/{chat_id}\"\n        \n        chat_text += f\"‚Ä¢ [{title}]({chat_link}) - {rank}\\n\"\n    \n    try:\n        if os.path.exists(image_path):\n            photo = FSInputFile(image_path)\n            await message.answer_photo(\n                photo=photo,\n                caption=chat_text,\n                parse_mode=\"Markdown\"\n            )\n        else:\n            await message.answer(chat_text, parse_mode=\"Markdown\")\n    except Exception as e:\n        await message.answer(chat_text, parse_mode=\"Markdown\")\n\n@router.message(F.text == \"üìã –ö–æ–º–∞–Ω–¥—ã\")\nasync def commands_button(message: Message):\n    \"\"\"Handle 'Commands' button\"\"\"\n    await help_command(message)","size_bytes":6061},"CustosBot/handlers/moderation_handlers.py":{"content":"from aiogram import F, Router\nfrom aiogram.types import Message, CallbackQuery\nfrom aiogram.filters import Command\nfrom data.database import Database\nfrom config import RANKS, RANK_NAMES, COMMAND_PERMISSIONS, RATE_LIMITS\nfrom keyboards.main_keyboards import get_confirmation_keyboard\nimport re\nfrom datetime import datetime, timedelta\n\nrouter = Router()\ndb = Database()\n\n# Rate limit storage (in production, use Redis or database)\nrate_limits = {}\n\nasync def check_rate_limit(user_id: int, command: str, rank: str) -> bool:\n    \"\"\"Check if user is rate limited for command\"\"\"\n    if rank in ['administrator', 'owner']:\n        return True  # No rate limits for high ranks\n    \n    limit_key = f\"{user_id}_{command}\"\n    current_time = datetime.now()\n    \n    if limit_key in rate_limits:\n        last_used = rate_limits[limit_key]\n        if command == 'warn' and rank == 'moderator':\n            if current_time - last_used < timedelta(seconds=RATE_LIMITS['warn_moderator']):\n                return False\n        elif command == 'kick' and rank == 'moderator':\n            if current_time - last_used < timedelta(seconds=RATE_LIMITS['kick_moderator']):\n                return False\n    \n    rate_limits[limit_key] = current_time\n    return True\n\nasync def get_target_user(message: Message, text: str) -> tuple[int, str]:\n    \"\"\"Extract target user from command\"\"\"\n    # Check if it's a reply\n    if message.reply_to_message and message.reply_to_message.from_user:\n        user = message.reply_to_message.from_user\n        return user.id, user.first_name or user.username or str(user.id)\n    \n    # Parse username or user ID from text\n    words = text.split()[2:]  # Skip command and number if present\n    if words:\n        target = words[0]\n        if target.startswith('@'):\n            # Username - in real implementation, you'd need to resolve this\n            return 0, target  # Placeholder\n        elif target.isdigit():\n            return int(target), target\n    \n    return 0, \"\"\n\n@router.message(Command(\"upstaff\"))\nasync def upstaff_command(message: Message):\n    \"\"\"Handle /upstaff command for rank promotion\"\"\"\n    user = message.from_user\n    chat = message.chat\n    \n    if not user or chat.type == 'private':\n        await message.answer(\"‚ùå –ö–æ–º–∞–Ω–¥–∞ –¥–æ—Å—Ç—É–ø–Ω–∞ —Ç–æ–ª—å–∫–æ –≤ –≥—Ä—É–ø–ø–æ–≤—ã—Ö —á–∞—Ç–∞—Ö!\")\n        return\n    \n    # Get user rank\n    user_rank = await db.get_user_rank(user.id, chat.id)\n    if not user_rank or user_rank not in COMMAND_PERMISSIONS['upstaff']:\n        await message.answer(\"‚ùå –°–ª–∏—à–∫–æ–º –Ω–∏–∑–∫–∏–π —Ä–∞–Ω–≥ –¥–ª—è –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏—è —ç—Ç–æ–π –∫–æ–º–∞–Ω–¥—ã!\")\n        return\n    \n    # Parse command: /upstaff [—á–∏—Å–ª–æ] [–ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å]\n    text = message.text or \"\"\n    parts = text.split()\n    \n    if len(parts) < 3:\n        await message.answer(\"‚ùå –ò—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ: `/upstaff [—á–∏—Å–ª–æ] [–ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å]`\", parse_mode=\"Markdown\")\n        return\n    \n    try:\n        rank_increase = int(parts[1])\n    except ValueError:\n        await message.answer(\"‚ùå –£–∫–∞–∂–∏—Ç–µ –∫–æ—Ä—Ä–µ–∫—Ç–Ω–æ–µ —á–∏—Å–ª–æ –¥–ª—è –ø–æ–≤—ã—à–µ–Ω–∏—è —Ä–∞–Ω–≥–∞!\")\n        return\n    \n    # Get target user\n    target_user_id, target_name = await get_target_user(message, text)\n    if not target_user_id:\n        await message.answer(\"‚ùå –ù–µ —É–¥–∞–ª–æ—Å—å –Ω–∞–π—Ç–∏ —É–∫–∞–∑–∞–Ω–Ω–æ–≥–æ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è!\")\n        return\n    \n    # Get target user current rank\n    target_rank = await db.get_user_rank(target_user_id, chat.id)\n    if not target_rank:\n        await message.answer(\"‚ùå –ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –Ω–µ –Ω–∞–π–¥–µ–Ω –≤ —á–∞—Ç–µ!\")\n        return\n    \n    current_rank_level = RANKS[target_rank]\n    new_rank_level = min(current_rank_level + rank_increase, 3)  # Max is owner (3)\n    \n    # Find new rank name\n    new_rank = None\n    for rank_name, level in RANKS.items():\n        if level == new_rank_level:\n            new_rank = rank_name\n            break\n    \n    if not new_rank or new_rank == target_rank:\n        await message.answer(\"‚ùå –ù–µ–≤–æ–∑–º–æ–∂–Ω–æ –ø–æ–≤—ã—Å–∏—Ç—å –¥–æ —É–∫–∞–∑–∞–Ω–Ω–æ–≥–æ —Ä–∞–Ω–≥–∞!\")\n        return\n    \n    # Permission check\n    if user_rank == 'administrator' and target_rank == 'owner':\n        await message.answer(\"‚ùå –ê–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä –Ω–µ –º–æ–∂–µ—Ç –ø–æ–≤—ã—à–∞—Ç—å –≤–ª–∞–¥–µ–ª—å—Ü–∞!\")\n        return\n    \n    # Special confirmation for promoting to owner\n    if new_rank == 'owner' and user_rank == 'owner':\n        keyboard = get_confirmation_keyboard(\"promote_owner\", target_user_id)\n        await message.answer(\n            f\"‚ö†Ô∏è –í—ã —Å–æ–±–∏—Ä–∞–µ—Ç–µ—Å—å –ø–µ—Ä–µ–¥–∞—Ç—å –ø—Ä–∞–≤–∞ –≤–ª–∞–¥–µ–ª—å—Ü–∞ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—é {target_name}. –ü–æ–¥—Ç–≤–µ—Ä–¥–∏—Ç–µ –¥–µ–π—Å—Ç–≤–∏–µ:\",\n            reply_markup=keyboard\n        )\n        return\n    \n    # Perform promotion\n    await db.update_user_rank(target_user_id, chat.id, new_rank)\n    \n    await message.answer(\n        f\"‚úÖ {target_name} –ø–æ–≤—ã—à–µ–Ω –≤ —Ä–∞–Ω–≥–µ, —Ç–µ–ø–µ—Ä—å –æ–Ω {RANK_NAMES[new_rank]}!\"\n    )\n\n@router.callback_query(F.data.startswith(\"confirm_promote_owner_\"))\nasync def confirm_owner_promotion(callback: CallbackQuery):\n    \"\"\"Handle owner promotion confirmation\"\"\"\n    user = callback.from_user\n    chat = callback.message.chat if callback.message else None\n    \n    if not user or not chat:\n        return\n    \n    # Check if user is owner\n    user_rank = await db.get_user_rank(user.id, chat.id)\n    if user_rank != 'owner':\n        await callback.answer(\"üö´ –≠—Ç–∞ –∫–Ω–æ–ø–∫–∞ –Ω–µ –¥–ª—è –≤–∞—Å ^-^\", show_alert=True)\n        return\n    \n    # Extract target user ID\n    if callback.data:\n        target_user_id = int(callback.data.split(\"_\")[-1])\n    else:\n        await callback.answer(\"‚ùå –û—à–∏–±–∫–∞ –¥–∞–Ω–Ω—ã—Ö\", show_alert=True)\n        return\n    \n    # Perform promotion\n    await db.update_user_rank(target_user_id, chat.id, 'owner')\n    await db.update_user_rank(user.id, chat.id, 'administrator')  # Demote current owner\n    \n    if callback.message and hasattr(callback.message, 'edit_text'):\n        await callback.message.edit_text(\"‚úÖ –ü—Ä–∞–≤–∞ –≤–ª–∞–¥–µ–ª—å—Ü–∞ —É—Å–ø–µ—à–Ω–æ –ø–µ—Ä–µ–¥–∞–Ω—ã!\")\n    await callback.answer()\n\n@router.message(Command(\"ban\"))\nasync def ban_command(message: Message):\n    \"\"\"Handle /ban command\"\"\"\n    user = message.from_user\n    chat = message.chat\n    \n    if not user or chat.type == 'private':\n        await message.answer(\"‚ùå –ö–æ–º–∞–Ω–¥–∞ –¥–æ—Å—Ç—É–ø–Ω–∞ —Ç–æ–ª—å–∫–æ –≤ –≥—Ä—É–ø–ø–æ–≤—ã—Ö —á–∞—Ç–∞—Ö!\")\n        return\n    \n    # Check permissions\n    user_rank = await db.get_user_rank(user.id, chat.id)\n    if not user_rank or user_rank not in COMMAND_PERMISSIONS['ban']:\n        await message.answer(\"‚ùå –ù–µ–¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ –ø—Ä–∞–≤ –¥–ª—è –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏—è —ç—Ç–æ–π –∫–æ–º–∞–Ω–¥—ã!\")\n        return\n    \n    text = message.text or \"\"\n    parts = text.split(maxsplit=2)\n    \n    if len(parts) < 3:\n        await message.answer(\"‚ùå –ò—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ: `/ban [–ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å] [–ø—Ä–∏—á–∏–Ω–∞]`\", parse_mode=\"Markdown\")\n        return\n    \n    target_user_id, target_name = await get_target_user(message, text)\n    reason = parts[2] if len(parts) > 2 else \"–ù–∞—Ä—É—à–µ–Ω–∏–µ –ø—Ä–∞–≤–∏–ª\"\n    \n    if not target_user_id:\n        await message.answer(\"‚ùå –ù–µ —É–¥–∞–ª–æ—Å—å –Ω–∞–π—Ç–∏ —É–∫–∞–∑–∞–Ω–Ω–æ–≥–æ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è!\")\n        return\n    \n    try:\n        # Try to ban user from chat\n        await message.chat.ban(target_user_id)\n        await message.answer(f\"üö´ {target_name} –∏—Å–∫–ª—é—á–µ–Ω –∏–∑ —á–∞—Ç–∞.\\n–ü—Ä–∏—á–∏–Ω–∞: {reason}\")\n    except Exception as e:\n        await message.answer(f\"‚ùå –ù–µ —É–¥–∞–ª–æ—Å—å –∑–∞–±–∞–Ω–∏—Ç—å –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è: {str(e)}\")\n\n@router.message(Command(\"warn\"))\nasync def warn_command(message: Message):\n    \"\"\"Handle /warn command\"\"\"\n    user = message.from_user\n    chat = message.chat\n    \n    if not user or chat.type == 'private':\n        await message.answer(\"‚ùå –ö–æ–º–∞–Ω–¥–∞ –¥–æ—Å—Ç—É–ø–Ω–∞ —Ç–æ–ª—å–∫–æ –≤ –≥—Ä—É–ø–ø–æ–≤—ã—Ö —á–∞—Ç–∞—Ö!\")\n        return\n    \n    # Check permissions\n    user_rank = await db.get_user_rank(user.id, chat.id)\n    if not user_rank or user_rank not in COMMAND_PERMISSIONS['warn']:\n        await message.answer(\"‚ùå –ù–µ–¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ –ø—Ä–∞–≤ –¥–ª—è –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏—è —ç—Ç–æ–π –∫–æ–º–∞–Ω–¥—ã!\")\n        return\n    \n    # Check rate limit\n    if not await check_rate_limit(user.id, 'warn', user_rank):\n        await message.answer(\"‚è∞ –í—ã –º–æ–∂–µ—Ç–µ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å —ç—Ç—É –∫–æ–º–∞–Ω–¥—É —Ä–∞–∑ –≤ —á–∞—Å!\")\n        return\n    \n    text = message.text or \"\"\n    parts = text.split(maxsplit=2)\n    \n    if len(parts) < 3:\n        await message.answer(\"‚ùå –ò—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ: `/warn [–ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å] [–ø—Ä–∏—á–∏–Ω–∞]`\", parse_mode=\"Markdown\")\n        return\n    \n    target_user_id, target_name = await get_target_user(message, text)\n    reason = parts[2] if len(parts) > 2 else \"–ù–∞—Ä—É—à–µ–Ω–∏–µ –ø—Ä–∞–≤–∏–ª\"\n    \n    if not target_user_id:\n        await message.answer(\"‚ùå –ù–µ —É–¥–∞–ª–æ—Å—å –Ω–∞–π—Ç–∏ —É–∫–∞–∑–∞–Ω–Ω–æ–≥–æ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è!\")\n        return\n    \n    # Add warning\n    await db.add_warning(target_user_id, chat.id, reason, user.id)\n    \n    # Check warning count\n    warning_count = await db.get_warning_count(target_user_id, chat.id)\n    \n    if warning_count >= 5:\n        try:\n            await message.chat.ban(target_user_id)\n            await message.answer(f\"üö´ {target_name} –ø–æ–ª—É—á–∏–ª 5-–π –≤–∞—Ä–Ω –∏ –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏ –∑–∞–±–∞–Ω–µ–Ω!\")\n        except Exception as e:\n            await message.answer(f\"‚ö†Ô∏è {target_name} –ø–æ–ª—É—á–∏–ª {warning_count}-–π –≤–∞—Ä–Ω! –ü—Ä–∏—á–∏–Ω–∞: {reason}\")\n    else:\n        await message.answer(f\"‚ö†Ô∏è {target_name} –ø–æ–ª—É—á–∏–ª –≤–∞—Ä–Ω ({warning_count}/5). –ü—Ä–∏—á–∏–Ω–∞: {reason}\")\n\n@router.message(Command(\"kick\"))\nasync def kick_command(message: Message):\n    \"\"\"Handle /kick command\"\"\"\n    user = message.from_user\n    chat = message.chat\n    \n    if not user or chat.type == 'private':\n        await message.answer(\"‚ùå –ö–æ–º–∞–Ω–¥–∞ –¥–æ—Å—Ç—É–ø–Ω–∞ —Ç–æ–ª—å–∫–æ –≤ –≥—Ä—É–ø–ø–æ–≤—ã—Ö —á–∞—Ç–∞—Ö!\")\n        return\n    \n    # Check permissions\n    user_rank = await db.get_user_rank(user.id, chat.id)\n    if not user_rank or user_rank not in COMMAND_PERMISSIONS['kick']:\n        await message.answer(\"‚ùå –ù–µ–¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ –ø—Ä–∞–≤ –¥–ª—è –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏—è —ç—Ç–æ–π –∫–æ–º–∞–Ω–¥—ã!\")\n        return\n    \n    # Check rate limit\n    if not await check_rate_limit(user.id, 'kick', user_rank):\n        await message.answer(\"‚è∞ –ú–æ–¥–µ—Ä–∞—Ç–æ—Ä –º–æ–∂–µ—Ç –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å —ç—Ç—É –∫–æ–º–∞–Ω–¥—É —Ä–∞–∑ –≤ 15 –º–∏–Ω—É—Ç!\")\n        return\n    \n    text = message.text or \"\"\n    parts = text.split(maxsplit=2)\n    \n    if len(parts) < 3:\n        await message.answer(\"‚ùå –ò—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ: `/kick [–ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å] [–ø—Ä–∏—á–∏–Ω–∞]`\", parse_mode=\"Markdown\")\n        return\n    \n    target_user_id, target_name = await get_target_user(message, text)\n    reason = parts[2] if len(parts) > 2 else \"–ù–∞—Ä—É—à–µ–Ω–∏–µ –ø—Ä–∞–≤–∏–ª\"\n    \n    if not target_user_id:\n        await message.answer(\"‚ùå –ù–µ —É–¥–∞–ª–æ—Å—å –Ω–∞–π—Ç–∏ —É–∫–∞–∑–∞–Ω–Ω–æ–≥–æ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è!\")\n        return\n    \n    try:\n        # Kick user (unban immediately after ban)\n        await message.chat.ban(target_user_id)\n        await message.chat.unban(target_user_id)\n        await message.answer(f\"üë¢ {target_name} –∏—Å–∫–ª—é—á–µ–Ω –∏–∑ —á–∞—Ç–∞ –≤—Ä–µ–º–µ–Ω–Ω–æ.\\n–ü—Ä–∏—á–∏–Ω–∞: {reason}\")\n    except Exception as e:\n        await message.answer(f\"‚ùå –ù–µ —É–¥–∞–ª–æ—Å—å –∫–∏–∫–Ω—É—Ç—å –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è: {str(e)}\")\n\n@router.message(Command(\"staff\"))\nasync def staff_command(message: Message):\n    \"\"\"Handle /staff command\"\"\"\n    chat = message.chat\n    \n    if chat.type == 'private':\n        await message.answer(\"‚ùå –ö–æ–º–∞–Ω–¥–∞ –¥–æ—Å—Ç—É–ø–Ω–∞ —Ç–æ–ª—å–∫–æ –≤ –≥—Ä—É–ø–ø–æ–≤—ã—Ö —á–∞—Ç–∞—Ö!\")\n        return\n    \n    # Get staff list\n    staff = await db.get_staff_list(chat.id)\n    \n    staff_text = \"üë• **–ü–µ—Ä—Å–æ–Ω–∞–ª —á–∞—Ç–∞:**\\n\\n\"\n    \n    # Owners\n    if staff['owner']:\n        staff_text += \"üëë **–í–ª–∞–¥–µ–ª—å—Ü—ã:**\\n\"\n        for member in staff['owner']:\n            name = member['nickname'] or member['first_name'] or member['username'] or str(member['user_id'])\n            staff_text += f\"‚Ä¢ {name}\\n\"\n        staff_text += \"\\n\"\n    \n    # Administrators\n    if staff['administrator']:\n        staff_text += \"‚≠ê **–ê–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä—ã:**\\n\"\n        for member in staff['administrator']:\n            name = member['nickname'] or member['first_name'] or member['username'] or str(member['user_id'])\n            staff_text += f\"‚Ä¢ {name}\\n\"\n        staff_text += \"\\n\"\n    \n    # Moderators\n    if staff['moderator']:\n        staff_text += \"üõ° **–ú–æ–¥–µ—Ä–∞—Ç–æ—Ä—ã:**\\n\"\n        for member in staff['moderator']:\n            name = member['nickname'] or member['first_name'] or member['username'] or str(member['user_id'])\n            staff_text += f\"‚Ä¢ {name}\\n\"\n    \n    if not any(staff.values()):\n        staff_text += \"–ü–µ—Ä—Å–æ–Ω–∞–ª –Ω–µ –Ω–∞–∑–Ω–∞—á–µ–Ω.\"\n    \n    await message.answer(staff_text, parse_mode=\"Markdown\")","size_bytes":13353},"CustosBot/handlers/user_handlers.py":{"content":"from aiogram import F, Router\nfrom aiogram.types import Message, FSInputFile\nfrom aiogram.filters import Command\nfrom data.database import Database\nfrom utils.image_generator import image_gen\nfrom config import RANK_NAMES\nimport os\n\nrouter = Router()\ndb = Database()\n\nasync def get_target_user_for_profile(message: Message) -> tuple[int, str]:\n    \"\"\"Get target user for profile commands\"\"\"\n    # Check if it's a reply\n    if message.reply_to_message and message.reply_to_message.from_user:\n        user = message.reply_to_message.from_user\n        return user.id, user.first_name or user.username or str(user.id)\n    \n    # Parse username from command\n    text = message.text or \"\"\n    parts = text.split()\n    if len(parts) > 1:\n        target = parts[1]\n        if target.startswith('@'):\n            # In real implementation, resolve username\n            return 0, target\n        elif target.isdigit():\n            return int(target), target\n    \n    return 0, \"\"\n\n@router.message(Command(\"me\"))\n@router.message(F.text.lower() == \"–∫—Ç–æ —è\")\nasync def me_command(message: Message):\n    \"\"\"Handle /me and '–∫—Ç–æ —è' commands\"\"\"\n    user = message.from_user\n    chat = message.chat\n    \n    if not user or chat.type == 'private':\n        await message.answer(\"‚ùå –ö–æ–º–∞–Ω–¥–∞ –¥–æ—Å—Ç—É–ø–Ω–∞ —Ç–æ–ª—å–∫–æ –≤ –≥—Ä—É–ø–ø–æ–≤—ã—Ö —á–∞—Ç–∞—Ö!\")\n        return\n    \n    # Generate user profile image if not exists\n    image_path = \"CustosBot/images/user_profile.png\"\n    if not os.path.exists(image_path):\n        try:\n            await image_gen.generate_user_profile_image()\n        except Exception as e:\n            print(f\"Failed to generate user profile image: {e}\")\n    \n    # Get user info\n    user_info = await db.get_user_info(user.id)\n    user_rank = await db.get_user_rank(user.id, chat.id)\n    message_count = await db.get_user_message_count(user.id, chat.id)\n    \n    # Build profile text\n    display_name = (user_info['nickname'] if user_info and user_info['nickname'] \n                   else user.first_name or user.username or str(user.id))\n    \n    profile_text = f\"üë§ **–û–ø–∏—Å–∞–Ω–∏–µ —á–∞—Ç–µ—Ä–∞**\\n\\n\"\n    profile_text += f\"**–ò–º—è:** {display_name}\\n\"\n    profile_text += f\"**–°—Å—ã–ª–∫–∞:** [–ü—Ä–æ—Ñ–∏–ª—å](tg://user?id={user.id})\\n\"\n    profile_text += f\"**–°–æ–æ–±—â–µ–Ω–∏–π:** {message_count}\\n\"\n    profile_text += f\"**–†–∞–Ω–≥:** {RANK_NAMES.get(user_rank, '–ù–µ–∏–∑–≤–µ—Å—Ç–µ–Ω')}\\n\"\n    \n    if user_info and user_info['description']:\n        profile_text += f\"**–û–ø–∏—Å–∞–Ω–∏–µ:** {user_info['description']}\\n\"\n    else:\n        profile_text += \"**–û–ø–∏—Å–∞–Ω–∏–µ:** –Ω–µ —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–æ\\n\"\n    \n    try:\n        if os.path.exists(image_path):\n            photo = FSInputFile(image_path)\n            await message.answer_photo(\n                photo=photo,\n                caption=profile_text,\n                parse_mode=\"Markdown\"\n            )\n        else:\n            await message.answer(profile_text, parse_mode=\"Markdown\")\n    except Exception as e:\n        await message.answer(profile_text, parse_mode=\"Markdown\")\n\n@router.message(Command(\"you\"))\n@router.message(F.text.lower() == \"–∫—Ç–æ —Ç—ã\")\nasync def you_command(message: Message):\n    \"\"\"Handle /you and '–∫—Ç–æ —Ç—ã' commands\"\"\"\n    user = message.from_user\n    chat = message.chat\n    \n    if not user or chat.type == 'private':\n        await message.answer(\"‚ùå –ö–æ–º–∞–Ω–¥–∞ –¥–æ—Å—Ç—É–ø–Ω–∞ —Ç–æ–ª—å–∫–æ –≤ –≥—Ä—É–ø–ø–æ–≤—ã—Ö —á–∞—Ç–∞—Ö!\")\n        return\n    \n    # Get target user\n    target_user_id, target_name = await get_target_user_for_profile(message)\n    \n    if not target_user_id:\n        await message.answer(\"‚ùå –£–∫–∞–∂–∏—Ç–µ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è: `/you @username` –∏–ª–∏ –æ—Ç–≤–µ—Ç—å—Ç–µ –Ω–∞ —Å–æ–æ–±—â–µ–Ω–∏–µ\", parse_mode=\"Markdown\")\n        return\n    \n    # Generate user profile image if not exists\n    image_path = \"CustosBot/images/user_profile.png\"\n    if not os.path.exists(image_path):\n        try:\n            await image_gen.generate_user_profile_image()\n        except Exception as e:\n            print(f\"Failed to generate user profile image: {e}\")\n    \n    # Get user info\n    user_info = await db.get_user_info(target_user_id)\n    user_rank = await db.get_user_rank(target_user_id, chat.id)\n    message_count = await db.get_user_message_count(target_user_id, chat.id)\n    \n    if not user_rank:\n        await message.answer(\"‚ùå –ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –Ω–µ –Ω–∞–π–¥–µ–Ω –≤ —á–∞—Ç–µ!\")\n        return\n    \n    # Build profile text\n    display_name = (user_info['nickname'] if user_info and user_info['nickname'] \n                   else target_name)\n    \n    profile_text = f\"üë§ **–û–ø–∏—Å–∞–Ω–∏–µ —á–∞—Ç–µ—Ä–∞**\\n\\n\"\n    profile_text += f\"**–ò–º—è:** {display_name}\\n\"\n    profile_text += f\"**–°—Å—ã–ª–∫–∞:** [–ü—Ä–æ—Ñ–∏–ª—å](tg://user?id={target_user_id})\\n\"\n    profile_text += f\"**–°–æ–æ–±—â–µ–Ω–∏–π:** {message_count}\\n\"\n    profile_text += f\"**–†–∞–Ω–≥:** {RANK_NAMES.get(user_rank, '–ù–µ–∏–∑–≤–µ—Å—Ç–µ–Ω')}\\n\"\n    \n    if user_info and user_info['description']:\n        profile_text += f\"**–û–ø–∏—Å–∞–Ω–∏–µ:** {user_info['description']}\\n\"\n    else:\n        profile_text += \"**–û–ø–∏—Å–∞–Ω–∏–µ:** –Ω–µ —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–æ\\n\"\n    \n    try:\n        if os.path.exists(image_path):\n            photo = FSInputFile(image_path)\n            await message.answer_photo(\n                photo=photo,\n                caption=profile_text,\n                parse_mode=\"Markdown\"\n            )\n        else:\n            await message.answer(profile_text, parse_mode=\"Markdown\")\n    except Exception as e:\n        await message.answer(profile_text, parse_mode=\"Markdown\")\n\n@router.message(Command(\"nickname\"))\n@router.message(F.text.startswith(\"+–Ω–∏–∫ \"))\n@router.message(F.text.startswith(\"+–∏–º—è \"))\nasync def nickname_command(message: Message):\n    \"\"\"Handle nickname setting commands\"\"\"\n    user = message.from_user\n    chat = message.chat\n    \n    if not user or chat.type == 'private':\n        await message.answer(\"‚ùå –ö–æ–º–∞–Ω–¥–∞ –¥–æ—Å—Ç—É–ø–Ω–∞ —Ç–æ–ª—å–∫–æ –≤ –≥—Ä—É–ø–ø–æ–≤—ã—Ö —á–∞—Ç–∞—Ö!\")\n        return\n    \n    text = message.text or \"\"\n    \n    # Parse nickname from different command formats\n    nickname = \"\"\n    if text.startswith(\"/nickname \"):\n        nickname = text[10:].strip()\n    elif text.startswith(\"+–Ω–∏–∫ \"):\n        nickname = text[5:].strip()\n    elif text.startswith(\"+–∏–º—è \"):\n        nickname = text[5:].strip()\n    \n    if not nickname:\n        await message.answer(\"‚ùå –£–∫–∞–∂–∏—Ç–µ –Ω–∏–∫–Ω–µ–π–º: `/nickname –í–∞—à–ù–∏–∫–Ω–µ–π–º`\", parse_mode=\"Markdown\")\n        return\n    \n    if len(nickname) > 50:\n        await message.answer(\"‚ùå –ù–∏–∫–Ω–µ–π–º –Ω–µ –º–æ–∂–µ—Ç –±—ã—Ç—å –¥–ª–∏–Ω–Ω–µ–µ 50 —Å–∏–º–≤–æ–ª–æ–≤!\")\n        return\n    \n    # Set nickname\n    await db.set_user_nickname(user.id, nickname)\n    await message.answer(f\"‚úÖ –ù–∏–∫–Ω–µ–π–º —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω: **{nickname}**\", parse_mode=\"Markdown\")\n\n@router.message(Command(\"description\"))\n@router.message(F.text.startswith(\"+–æ–ø–∏—Å \"))\n@router.message(F.text.startswith(\"+–æ–ø–∏—Å–∞–Ω–∏–µ \"))\nasync def description_command(message: Message):\n    \"\"\"Handle description setting commands\"\"\"\n    user = message.from_user\n    chat = message.chat\n    \n    if not user or chat.type == 'private':\n        await message.answer(\"‚ùå –ö–æ–º–∞–Ω–¥–∞ –¥–æ—Å—Ç—É–ø–Ω–∞ —Ç–æ–ª—å–∫–æ –≤ –≥—Ä—É–ø–ø–æ–≤—ã—Ö —á–∞—Ç–∞—Ö!\")\n        return\n    \n    text = message.text or \"\"\n    \n    # Parse description from different command formats\n    description = \"\"\n    if text.startswith(\"/description \"):\n        description = text[13:].strip()\n    elif text.startswith(\"+–æ–ø–∏—Å \"):\n        description = text[6:].strip()\n    elif text.startswith(\"+–æ–ø–∏—Å–∞–Ω–∏–µ \"):\n        description = text[10:].strip()\n    \n    if not description:\n        await message.answer(\"‚ùå –£–∫–∞–∂–∏—Ç–µ –æ–ø–∏—Å–∞–Ω–∏–µ: `/description –í–∞—à–µ –æ–ø–∏—Å–∞–Ω–∏–µ`\", parse_mode=\"Markdown\")\n        return\n    \n    if len(description) > 200:\n        await message.answer(\"‚ùå –û–ø–∏—Å–∞–Ω–∏–µ –Ω–µ –º–æ–∂–µ—Ç –±—ã—Ç—å –¥–ª–∏–Ω–Ω–µ–µ 200 —Å–∏–º–≤–æ–ª–æ–≤!\")\n        return\n    \n    # Set description\n    await db.set_user_description(user.id, description)\n    await message.answer(f\"‚úÖ –û–ø–∏—Å–∞–Ω–∏–µ —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–æ: **{description}**\", parse_mode=\"Markdown\")\n\n@router.message(F.content_type == \"text\")\nasync def track_messages(message: Message):\n    \"\"\"Track user messages for statistics\"\"\"\n    user = message.from_user\n    chat = message.chat\n    \n    if not user or chat.type == 'private':\n        return\n    \n    # Add user and chat if not exists\n    await db.add_user(user.id, user.username, user.first_name, user.last_name)\n    await db.add_chat(chat.id, chat.title or \"Unknown Chat\", chat.type)\n    await db.add_chat_member(user.id, chat.id)\n    \n    # Increment message count\n    await db.increment_message_count(user.id, chat.id)","size_bytes":8876},"CustosBot/keyboards/main_keyboards.py":{"content":"from aiogram.types import InlineKeyboardMarkup, InlineKeyboardButton, ReplyKeyboardMarkup, KeyboardButton\n\ndef get_main_menu_keyboard() -> InlineKeyboardMarkup:\n    \"\"\"Main menu keyboard with 'Add to chat' button\"\"\"\n    keyboard = InlineKeyboardMarkup(inline_keyboard=[\n        [InlineKeyboardButton(text=\"‚ûï –î–æ–±–∞–≤–∏—Ç—å –≤ —á–∞—Ç\", url=\"https://t.me/custoschatbot?startgroup=true\")]\n    ])\n    return keyboard\n\ndef get_menu_buttons_keyboard() -> ReplyKeyboardMarkup:\n    \"\"\"Regular keyboard with menu buttons\"\"\"\n    keyboard = ReplyKeyboardMarkup(\n        keyboard=[\n            [KeyboardButton(text=\"üí¨ –ú–æ–∏ —á–∞—Ç—ã\")],\n            [KeyboardButton(text=\"üìã –ö–æ–º–∞–Ω–¥—ã\")]\n        ],\n        resize_keyboard=True,\n        persistent=True\n    )\n    return keyboard\n\ndef get_confirmation_keyboard(action: str, target_user_id: int) -> InlineKeyboardMarkup:\n    \"\"\"Confirmation keyboard for sensitive actions like promoting to owner\"\"\"\n    keyboard = InlineKeyboardMarkup(inline_keyboard=[\n        [InlineKeyboardButton(text=\"‚úÖ –ü–æ–¥—Ç–≤–µ—Ä–¥–∏—Ç—å\", callback_data=f\"confirm_{action}_{target_user_id}\")]\n    ])\n    return keyboard\n\ndef get_back_keyboard() -> InlineKeyboardMarkup:\n    \"\"\"Simple back button\"\"\"\n    keyboard = InlineKeyboardMarkup(inline_keyboard=[\n        [InlineKeyboardButton(text=\"üîô –ù–∞–∑–∞–¥\", callback_data=\"back_to_menu\")]\n    ])\n    return keyboard","size_bytes":1392},"CustosBot/utils/__init__.py":{"content":"# Utils package","size_bytes":15},"CustosBot/utils/image_generator.py":{"content":"import os\nimport asyncio\nimport requests\nfrom PIL import Image, ImageDraw, ImageFont\nfrom io import BytesIO\nfrom openai import OpenAI\n\n# the newest OpenAI model is \"gpt-5\" which was released August 7, 2025.\n# do not change this unless explicitly requested by the user\n\nclass ImageGenerator:\n    def __init__(self):\n        self.openai_client = None\n        self.images_path = \"CustosBot/images\"\n        os.makedirs(self.images_path, exist_ok=True)\n        \n        # Initialize OpenAI client only if API key is available\n        openai_api_key = os.environ.get(\"OPENAI_API_KEY\")\n        if openai_api_key:\n            try:\n                self.openai_client = OpenAI(api_key=openai_api_key)\n            except Exception as e:\n                print(f\"Failed to initialize OpenAI client: {e}\")\n                self.openai_client = None\n    \n    async def generate_with_openai(self, prompt: str, filename: str) -> str:\n        \"\"\"Generate image using OpenAI DALL-E\"\"\"\n        # If OpenAI client is not available, fallback to local generation\n        if not self.openai_client:\n            print(\"OpenAI client not available, using local generation\")\n            return await self.generate_local(prompt, filename)\n            \n        try:\n            response = self.openai_client.images.generate(\n                model=\"dall-e-3\",\n                prompt=prompt,\n                n=1,\n                size=\"1024x1024\"\n            )\n            \n            # Download the image\n            if response.data and len(response.data) > 0:\n                image_url = response.data[0].url\n                if image_url:\n                    image_response = requests.get(image_url)\n                else:\n                    raise Exception(\"No image URL received from OpenAI\")\n            else:\n                raise Exception(\"No image data received from OpenAI\")\n            \n            if image_response.status_code == 200:\n                filepath = os.path.join(self.images_path, filename)\n                with open(filepath, 'wb') as f:\n                    f.write(image_response.content)\n                return filepath\n            else:\n                raise Exception(f\"Failed to download image: {image_response.status_code}\")\n                \n        except Exception as e:\n            print(f\"OpenAI generation failed: {e}\")\n            # Fallback to local generation\n            return await self.generate_local(prompt, filename)\n    \n    async def generate_local(self, text: str, filename: str) -> str:\n        \"\"\"Generate image locally using PIL as fallback\"\"\"\n        try:\n            # Create dark themed image\n            width, height = 1024, 1024\n            background_color = (30, 20, 60)  # Dark purple\n            text_color = (255, 255, 255)     # White text\n            accent_color = (138, 43, 226)    # Blue violet\n            \n            image = Image.new('RGB', (width, height), background_color)\n            draw = ImageDraw.Draw(image)\n            \n            # Try to use a nice font, fallback to default\n            try:\n                font_size = 80\n                font = ImageFont.truetype(\"/usr/share/fonts/truetype/dejavu/DejaVuSans-Bold.ttf\", font_size)\n            except:\n                font = ImageFont.load_default()\n            \n            # Calculate text position\n            bbox = draw.textbbox((0, 0), text, font=font)\n            text_width = bbox[2] - bbox[0]\n            text_height = bbox[3] - bbox[1]\n            \n            x = (width - text_width) // 2\n            y = (height - text_height) // 2\n            \n            # Draw accent background\n            margin = 50\n            draw.rectangle([x-margin, y-margin, x+text_width+margin, y+text_height+margin], \n                         fill=accent_color, outline=None)\n            \n            # Draw text\n            draw.text((x, y), text, fill=text_color, font=font)\n            \n            # Add decorative elements\n            for i in range(5):\n                circle_x = 100 + i * 200\n                circle_y = 100\n                draw.ellipse([circle_x-10, circle_y-10, circle_x+10, circle_y+10], \n                           fill=accent_color)\n            \n            filepath = os.path.join(self.images_path, filename)\n            image.save(filepath)\n            return filepath\n            \n        except Exception as e:\n            print(f\"Local generation failed: {e}\")\n            # Return a basic placeholder path\n            return os.path.join(self.images_path, filename)\n    \n    async def generate_main_menu_image(self) -> str:\n        \"\"\"Generate main menu cover image\"\"\"\n        prompt = \"\"\"\n        Dark themed logo for Telegram bot called 'Custos | –ß–∞—Ç-–º–µ–Ω–µ–¥–∂–µ—Ä'. \n        Modern minimalist design with dark purple, blue, black and white colors. \n        Dark background with elegant white text. \n        Futuristic chat management theme with geometric elements.\n        No realistic photos, just abstract geometric design.\n        \"\"\"\n        return await self.generate_with_openai(prompt, \"main_menu.png\")\n    \n    async def generate_commands_image(self) -> str:\n        \"\"\"Generate commands help image\"\"\"\n        prompt = \"\"\"\n        Dark themed header image with text '–ö–æ–º–∞–Ω–¥—ã' (Commands in Russian). \n        Dark purple and blue gradient background with white text. \n        Minimalist design with geometric elements and chat symbols.\n        Modern tech style, no realistic photos.\n        \"\"\"\n        return await self.generate_with_openai(prompt, \"commands.png\")\n    \n    async def generate_my_chats_image(self) -> str:\n        \"\"\"Generate my chats image\"\"\"\n        prompt = \"\"\"\n        Dark themed header image with text '–ú–æ–∏ —á–∞—Ç—ã' (My Chats in Russian). \n        Dark background with purple and blue accents. \n        Chat bubble icons and geometric elements. \n        Modern minimalist style, white text on dark background.\n        \"\"\"\n        return await self.generate_with_openai(prompt, \"my_chats.png\")\n    \n    async def generate_user_profile_image(self) -> str:\n        \"\"\"Generate user profile description image\"\"\"\n        prompt = \"\"\"\n        Dark themed image for user profile with text '–û–ø–∏—Å–∞–Ω–∏–µ —á–∞—Ç–µ—Ä–∞' (User Description in Russian).\n        Dark purple background with blue accents. \n        User avatar placeholder and profile elements.\n        Modern minimalist design with white text.\n        \"\"\"\n        return await self.generate_with_openai(prompt, \"user_profile.png\")\n    \n    async def generate_bot_avatar(self) -> str:\n        \"\"\"Generate bot avatar\"\"\"\n        prompt = \"\"\"\n        Bot avatar for 'Custos' chat manager. \n        Circular avatar with dark theme - purple, blue, black colors. \n        Modern robotic or AI assistant appearance. \n        Professional and trustworthy design. \n        No text, just the avatar icon.\n        \"\"\"\n        return await self.generate_with_openai(prompt, \"bot_avatar.png\")\n\n# Create global instance\nimage_gen = ImageGenerator()","size_bytes":6972}},"version":1}